#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\options openany
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "cmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Learning ZIL"
\pdf_author "Steven Eric Meretzky"
\pdf_subject "Everything You Always Wanted to KnowAbout Writing Interactive FictionBut Couldn't Find Anyone Still Working Here to Ask"
\pdf_keywords "Infocom ZIL Zork IF IntFiction Interactive Fiction"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\headheight 1cm
\headsep 0.5cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\listings_params "xleftmargin=25pt"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Learning ZIL
\end_layout

\begin_layout Subtitle
or
\begin_inset Newline newline
\end_inset


\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Everything You Always Wanted to Know
\begin_inset Newline newline
\end_inset

About Writing Interactive Fiction
\begin_inset Newline newline
\end_inset

But Couldn't Find Anyone Still Working Here to Ask
\end_layout

\begin_layout Author
Steven Eric Meretzky (SEM)
\end_layout

\begin_layout Date
8/1/95
\end_layout

\begin_layout Publishers
Copyright ©1989 Infocom, Inc.
 
\begin_inset Newline newline
\end_inset

For internal use only.
 
\begin_inset Newline newline
\end_inset

Comments to SEM
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
The Basics
\end_layout

\begin_layout Section
The Basic Ingredients
\end_layout

\begin_layout Standard
When you write interactive fiction (hereafter IF), you will mostly be dealing
 with two kinds of things: objects and routines.
 There are two major categories of objects: rooms (such as the Living Room
 in 
\emph on
\noun on
Zork I
\emph default
\noun default
 or Joe's Bar in 
\emph on
\noun on
Leather Goddesses
\emph default
\noun default
), and objects you can refer to, such as the brass lantern in 
\emph on
\noun on
Zork I
\emph default
\noun default
 or the dressing gown in 
\emph on
\noun on
Hitchhiker's Guide
\emph default
\noun default
.
 
\end_layout

\begin_layout Standard
Routines are little sub-programs which perform a whole variety of functions.
 There are many kinds of routines, but the kind you'll be concerned with
 first are called action routines.
 These are directly linked to a room or object.
 Much more detail on objects and routines in subsequent chapters.
\end_layout

\begin_layout Section
The Handler
\end_layout

\begin_layout Standard
In IF, the player types an input, and the game must produce a response:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>HIT UNCLE OTTO WITH THE HAMMER
\end_layout

\begin_layout Plain Layout

You knock some sense back into Uncle Otto, and he stops
\end_layout

\begin_layout Plain Layout

insisting that he's Napoleon Bonaparte.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Somewhere, the game decided to print that response.
 The part of the game that printed that response is said to have handled
 the input.
 The input must be handled at some point; a non-response is always a no-no:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>UNCLE OTTO, REMOVE YOUR HAND FROM YOUR SHIRT
\end_layout

\begin_layout Plain Layout

>
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Parser's Role
\end_layout

\begin_layout Standard
There's a notorious part of every IF program called the parser.
 It gets the first look at the input.
 If it decides that the input is indecipherable, for any of several reasons,
 it handles the input.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>EXAMINE THE FLEECY CLOUD
\end_layout

\begin_layout Plain Layout

[I don't know the word "fleecy."]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>ASK UNCLE OTTO ABOUT MOSCOW AND WATERLOO
\end_layout

\begin_layout Plain Layout

[You can't use multiple objects with the verb "ask."]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cases like these are called parser failures.
 (This is not to be confused with those times when the parser fails, which
 are called parser bugs.)
\end_layout

\begin_layout Standard
If the parser succeeds in digesting the input, it passes three pieces of
 information on to the rest of the program: the verb, the direct object,
 and the indirect object.
 Internally, these are called PRSA, PRSO, and PRSI.
 In the first example in section 1.1, PRSA is HIT, PRSO is the UNCLE OTTO
 object, and PRSI is the HAMMER object.
\end_layout

\begin_layout Standard
Not every input has a PRSI.
 For example, in:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>CALL THE FUNNY FARM
\end_layout

\begin_layout Plain Layout

Men in white coats arrive and hustle Uncle Otto into
\end_layout

\begin_layout Plain Layout

the wagon.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
the verb is CALL and the PRSO is the FUNNY FARM object.
 In such a case, when there is no PRSI, the parser sets the value of PRSI
 to false.
 Furthermore, not every input has a PRSO.
 Some examples of inputs where PRSO and PRSI are both false:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>YELL
\end_layout

\begin_layout Plain Layout

>PANIC
\end_layout

\begin_layout Plain Layout

>INVENTORY
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that you cannot have a PRSI without also having a PRSO.
 Also note that every input has a PRSA.
\end_layout

\begin_layout Section
The Basic Handling Sequence
\end_layout

\begin_layout Standard
After the parser identifies PRSA, PRSO, and PRSI, the game gets to decide
 who will handle the input.
 By convention, PRSI gets the first crack (providing there is a PRSI, of
 course).
 
\end_layout

\begin_layout Standard
What this means, is that if PRSI has an associated object action routine,
 that action routine tries to handle the input.
 If it does so, the current turn is considered to be complete.
 If not, then the PRSO's action routine is given the opportunity next.
 The PRSO and PRSI routines can give very specific responses to the input.
 
\end_layout

\begin_layout Standard
If the PRSO also fails to handle the input, the task falls to the routine
 associated with the verb.
 Because such a routine is the "last resort," and since it usually gives
 a very general response, it is called the default response.
 Here's an example of how the response to an input might look depending
 on who handled it:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>HIT THE OAK CHEST WITH THE CROWBAR
\end_layout

\begin_layout Plain Layout

The crowbar bends! It appears to be made of rubber, not
\end_layout

\begin_layout Plain Layout

iron!
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang ngerman
\begin_inset Formula $\rightarrow$
\end_inset


\lang english
 (handled by PRSI's action routine)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

The sound of the impact reverberates inside the chest.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang ngerman
\begin_inset Formula $\rightarrow$
\end_inset


\lang english
(handled by the PRSO's action routine)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

Hitting the oak chest accomplishes nothing.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang ngerman
\begin_inset Formula $\rightarrow$
\end_inset


\lang english
(handled by the verb default)
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

As you can see, the verb default is the least interesting and "colorful"
 of the responses.
 Of course, there's not enough space on the disk or time in the schedule
 to give every possible input its own special response; a good implementor
 must find the proper balance, deciding when to write a special colorful
 response, and when to let the relatively drab verb default do the handling.
\end_layout

\begin_layout Standard
There are other places where the game gets a chance to handle the input,
 but we'll get to that later on.
\end_layout

\begin_layout Chapter
Creating Rooms
\end_layout

\begin_layout Section
What a Typical Room Definition Looks Like
\end_layout

\begin_layout Standard
Here's what the definition of the Living Room from Zork I looks like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROOM LIVING-ROOM
\end_layout

\begin_layout Plain Layout

    (LOC ROOMS)
\end_layout

\begin_layout Plain Layout

    (DESC "Living Room")
\end_layout

\begin_layout Plain Layout

    (EAST TO KITCHEN)
\end_layout

\begin_layout Plain Layout

    (WEST TO STRANGE-PASSAGE IF CYCLOPS-FLED ELSE
\end_layout

\begin_layout Plain Layout

         "The wooden door is nailed shut.")
\end_layout

\begin_layout Plain Layout

    (DOWN PER TRAP-DOOR-EXIT)
\end_layout

\begin_layout Plain Layout

    (ACTION LIVING-ROOM-F)
\end_layout

\begin_layout Plain Layout

    (FLAGS RLANDBIT ONBIT SACREDBIT)
\end_layout

\begin_layout Plain Layout

    (GLOBAL STAIRS)
\end_layout

\begin_layout Plain Layout

    (THINGS <> NAILS NAILS-PSEUDO)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that, as with everything you will ever write in ZIL, the parentheses
 and angle brackets are balanced.
\end_layout

\begin_layout Standard
Let's go over this room definition line by line.
 The first thing in a room definition is the word ROOM followed by the internal
 name of the room.
 This name, like all names of objects or routines in ZIL, must be one word
 (or, if more than one word, connected by hyphens) and must be all capital
 letters.
\end_layout

\begin_layout Standard
The second line, LOC, gives its internal location.
 All rooms are located in a special object called the ROOMS object.
\end_layout

\begin_layout Standard
The third line is the external name of the room, its DESC.
 This is what will appear in the output each time a player enters that room.
 Note: The internal and external names of a room (or object) do not need
 to be identical.
 For example, there's no reason the internal name couldn't be LIV-ROOM.
 It's up to the author.
 Usually, it's a trade-off: using the same name makes it easier to remember
 the internal name, but it means more typing.
\end_layout

\begin_layout Section
Exits
\end_layout

\begin_layout Standard
The next several lines are all the exits from the Living Room.
 In general, the bulk of a room definition is its exits.
 The fourth line, (EAST TO KITCHEN), is an example of the simplest kind
 of exit, called a UEXIT (for unconditional exit).
 This means that when the player is in the Living Room and types EAST, the
 player will go to the Kitchen  —  in all cases.
\end_layout

\begin_layout Standard
The fifth line is a CEXIT (for conditional exit).
 If involves a global called CYCLOPS-FLED.
 A global is the simplest way that you store a piece of information in ZIL.
 (See section 5.2 and section 7.2.) In this case, CYCLOPSFLED is either true
 or false depending on whether the cyclops has made a hole in the oak door.
 What this CEXIT means is that when the player types WEST, the player will
 be sent to Strange Passage if the global CYCLOPS-FLED is true.
 If CYCLOPS-FLED is false, the player will be told "The door is nailed shut."
 This piece of text inside quotes is called a string.
 The string is not required for a CEXIT; if it is omitted, the game will
 supply a default string like "You can't go that way."
\end_layout

\begin_layout Standard
The sixth line is an example of an FEXIT (for function exit).
 (Function is another word for routine.) The game will recognize this line
 as an FEXIT because of the "PER." In this case, if the player types DOWN,
 the routine called TRAP-DOOREXIT decides if the player can move, and if
 so, to where, and if not, what the response should be.
 In this case, it will say "You can't go that way." if you haven't moved
 the rug, or "The trap door is closed." if you have moved the rug but haven't
 opened the trap door.
\end_layout

\begin_layout Standard
There are two other types of exits, which don't happen to be used by the
 Living Room in Zork I.
 The NEXIT (for non-exit) is simply a direction in which you can never go,
 but for which you want something more interesting than the default "You
 can't go that way." response.
 The game will recognize it as an NEXIT because of the use of "SORRY." It
 might look something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

(NW SORRY "The soldier at Uncle Otto's front door
\end_layout

\begin_layout Plain Layout

informs you that only Emperor Bonaparte is allowed
\end_layout

\begin_layout Plain Layout

through.")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The other is the DEXIT (for door exit).
 This is similar to the CEXIT, substituting the condition of a door object
 for the global.
 It might look something like this.
 Note the "IS OPEN" which isn't found in a CEXIT:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

(SOUTH TO GARAGE IF GARAGE-DOOR IS OPEN ELSE
\end_layout

\begin_layout Plain Layout

"You ought to use the garage door opener.")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the GARAGE-DOOR object is open, and the player types SOUTH, you'll end
 up in the GARAGE.
 Else, the player will be told the string.
 Once again, the string is optional.
 If no string is supplied, the response will be something like "You'll have
 to open the garage door, first."
\end_layout

\begin_layout Section
Other Parts of a Room Definition
\end_layout

\begin_layout Standard
Getting back to the Living Room example, the next line defines the room's
 action routine, LIVING-ROOM-F.
 (The F at the end is short for "function.") You'll hear (a lot) more about
 a room's action routine in a while.
\end_layout

\begin_layout Standard
The next line contains those FLAGS which are applicable to this room.
 RLANDBIT (the R is for "room") means that the room is on dry land, rather
 than water (such as the Reservoir) or in the air (such as the volcano rooms
 in Zork II).
 ONBIT means that the room is always lit.
 Some flag names appear in every game; but you can make up special ones
 to fit the requirements of your own game.
 For example, SACREDBIT is special to Zork I, and means that the thief never
 visits this room.
 By convention, all flag names end with "BIT." For a complete list of commonly
 used flags, see Appendix B.
\end_layout

\begin_layout Standard
Forget about the GLOBAL and THINGS lines for now.
 You'll learn about the GLOBAL property in section 7.4, and can read about
 THINGS in Appendix A.
 All these things — EAST, UP, FLAGS, ACTION, etc.
 — are called properties.
 As you'll see in a moment, objects have properties as well; some are the
 same as the properties that rooms have, but some are different.
 Although most properties are the same from game to game, you may occasionally
 want to create your own.
 For a complete list of commonly used properties, see the Appendix A.
\end_layout

\begin_layout Chapter
Creating Objects
\end_layout

\begin_layout Section
What an Object Definition Looks Like
\end_layout

\begin_layout Standard
Here's what the definition of Zork I's brass lantern looks like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<OBJECT LANTERN
\end_layout

\begin_layout Plain Layout

    (LOC LIVING-ROOM)
\end_layout

\begin_layout Plain Layout

    (SYNONYM LAMP LANTERN LIGHT)
\end_layout

\begin_layout Plain Layout

    (ADJECTIVE BRASS)
\end_layout

\begin_layout Plain Layout

    (DESC "brass lantern")
\end_layout

\begin_layout Plain Layout

    (FLAGS TAKEBIT LIGHTBIT)
\end_layout

\begin_layout Plain Layout

    (ACTION LANTERN-F)
\end_layout

\begin_layout Plain Layout

    (FDESC "A battery-powered lantern is on the trophy
\end_layout

\begin_layout Plain Layout

            case.")
\end_layout

\begin_layout Plain Layout

    (LDESC "There is a brass lantern (battery-powered)
\end_layout

\begin_layout Plain Layout

            here.")
\end_layout

\begin_layout Plain Layout

    (SIZE 15)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, there are some properties which appeared in the room example,
 but some new ones as well.
\end_layout

\begin_layout Section
Object properties
\end_layout

\begin_layout Standard
LOC refers to the location of the object at the start of the game.
 In this case, the location of the lamp is in the Living Room room.
 Over the course of the game, the location of objects may change as the
 player does stuff.
 For example, if the player picked up the lamp, the LOC of the lamp would
 then be the PLAYER (sometimes called PROTAGONIST) object.
 If the player then dropped the lamp in the Kitchen, the Kitchen room would
 be the lamp's LOC.
\end_layout

\begin_layout Standard
The SYNONYM property is a list of all those nouns which can be used to refer
 to the lamp.
 The ADJECTIVE property is a list of those adjectives which can be used
 to refer to the lamp.
 An object, to be referred to, must have at least one synonym; the ADJECTIVE
 property is optional.
 In the case of the lamp, the player could refer to it using any of six
 combinations: lamp, lantern, light, brass lamp, brass lantern, brass light.
\end_layout

\begin_layout Standard
The DESC property, as with rooms, is the name of the object for external
 consumption.
 It will appear whenever a routine needs to "plug in" the name of the object.
 For example, the EAT verb default would use it to form the output: "I doubt
 the brass lantern would agree with you."
\end_layout

\begin_layout Standard
The lamp has two flags: the TAKEBIT means that the lamp can be picked up
 by the player; the LIGHTBIT means that the lamp can be lit.
 The lamp is not currently on; once it gets turned on, it will have the
 ONBIT, meaning that it is giving off light.
 The flags in the object definition are only those attributes which the
 object has at the start of the game.
\end_layout

\begin_layout Standard
The ACTION property identifies LANTERN-F as the action routine which tries
 to handle inputs relating to the lantern.
 For example, if the player typed THROW THE NERF BALL AT THE BRASS LANTERN,
 the LAMP object would be the PRSI, and the routine LANTERN-F would get
 the first crack at handling the input.
 If the player typed THROW THE BRASS LANTERN AT THE NERF BALL, then the
 LAMP object would be the PRSO, and LANTERN-F would get a crack at handling
 the input provided that the nerf ball's action routine failed to do so.
 The FDESC property is a string which is used to describe the brass lantern
 until the player picks it up for the first time; in other words, it describes
 its original state.
 The LDESC property is a string which subsequently describes the lantern
 when it's on the ground.
 These strings are used when a room description is given, which occurs when
 you enter a room or when you do a LOOK.
 If there are no FDESC or LDESC properties, an object will be described
 by plugging its DESC into a default: "There is a brass lantern here."
\end_layout

\begin_layout Standard
The SIZE property defines the size/weight of the object.
 This helps the game decide things like whether you can pick something up,
 or whether you're holding too much already.
 If no SIZE is given to a takeable object, the default is usually 5.
 A very light object, like a key or a credit card, might have a SIZE of
 1 or 2.
 A very heavy object, like a trunk or anvil, might have a SIZE of 25 or
 50.
 Don't worry too much when you're creating the object; you can always go
 back and tweak the sizes during the testing phase.
\end_layout

\begin_layout Chapter
Routines in ZIL
\end_layout

\begin_layout Section
The Basic Parts
\end_layout

\begin_layout Standard
A routine is the most common item that makes up ZIL code.
 If you think of rooms and objects as the skeletal structure of a game,
 then routines are the blood and muscle that make the skeleton dance.
\end_layout

\begin_layout Standard
Like all things in ZIL, a routine must have balanced sets of parentheses
 and angle brackets.
 The basic parts of a routine look like this.
 Note how the angle brackets balance out:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE ROUTINE-NAME (argument-list)
\end_layout

\begin_layout Plain Layout

    <guts of the routine>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are various conventions for naming routines; object and room action
 routines are usually the name of the object or room with "-F" appended.
 As usual, there's a trade-off between shorter, easier to type names and
 longer, easier to remember and understand names.
\end_layout

\begin_layout Standard
The argument list appears within parentheses after the routine name.
 Arguments are variables used only within the specific routine — unlike
 global variables, which are used by any routine in the game.
 In many cases, a routine will have no arguments; in that case, the argument
 list must still appear, but as an empty set of parentheses: ().
\end_layout

\begin_layout Standard
Here's an example of a couple of simple routines, just to show you what
 they look like.
 You don't have to understand them fully, just yet:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE TURN-OFF-HOUSE-LIGHTS ()
\end_layout

\begin_layout Plain Layout

    <FCLEAR ,LIVING-ROOM ,ONBIT>
\end_layout

\begin_layout Plain Layout

    <FCLEAR ,DINING-ROOM ,ONBIT>
\end_layout

\begin_layout Plain Layout

    <FCLEAR ,KITCHEN ,ONBIT>>
\end_layout

\begin_layout Plain Layout

<ROUTINE INCREMENT-SCORE (NUM)
\end_layout

\begin_layout Plain Layout

    <SETG SCORE <+ ,SCORE .NUM>>
\end_layout

\begin_layout Plain Layout

    <COND (,SCORE-NOTIFICATION-ON
\end_layout

\begin_layout Plain Layout

        <TELL "[Your score has just gone up by "
\end_layout

\begin_layout Plain Layout

            N .NUM ".]" CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first routine, called TURN-OFF-HOUSE-LIGHTS, makes the three rooms in
 the house dark.
 Note the empty argument list.
\end_layout

\begin_layout Standard
The second routine, INCREMENT-SCORE, has one local argument, NUM.
 This routine adds the value of NUM to the player's score; if the player
 has the notification feature turned on, this routine will inform the player
 about the increase.
\end_layout

\begin_layout Section
Calling a Routine
\end_layout

\begin_layout Standard
Every routine in a game is activated by being called by some other routine.
 The PRSO and PRSI action routines, and the verb default routine, are called
 by a routine called PERFORM, which runs through the potential handlers
 and stops when someone has handled the input.
 In turn, an action routine can call other routines, as you will see.
\end_layout

\begin_layout Standard
A routine calls another routine by putting the name of the called routine
 at the appropriate place, inside brackets:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE ROUTINE-A ()
\end_layout

\begin_layout Plain Layout

    <TELL "Routine-B is about to be called by
\end_layout

\begin_layout Plain Layout

           Routine-A." CR>
\end_layout

\begin_layout Plain Layout

    <ROUTINE-B>
\end_layout

\begin_layout Plain Layout

    <TELL "Routine-B just called by Routine-A." CR>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sometimes, the caller may want to call the callee with an argument, in order
 to pass information to the callee.
 In that case, the argument list of the called routine must be set up to
 receive the passed arguments:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE RHYME ("AUX" ARG1 ARG2)
\end_layout

\begin_layout Plain Layout

    <SET ARG1 30>
\end_layout

\begin_layout Plain Layout

    <SET ARG2 "September">
\end_layout

\begin_layout Plain Layout

    <LINE-IN-RHYME .ARG1 .ARG2>
\end_layout

\begin_layout Plain Layout

    <SET ARG1 28>
\end_layout

\begin_layout Plain Layout

    <SET ARG2 "February">
\end_layout

\begin_layout Plain Layout

    <LINE-IN-RHYME .ARG1 .ARG2>
\end_layout

\begin_layout Plain Layout

    etc.>
\end_layout

\begin_layout Plain Layout

<ROUTINE LINE-IN-RHYME (ARG-A ARG-B)
\end_layout

\begin_layout Plain Layout

    <TELL N .ARG-A " days hath " .ARG-B "." CR>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that in the example above, routine RHYME has the notation "AUX" in
 its argument list before the two arguments.
 This means that the two arguments are auxiliary arguments, used within
 the routine RHYME, but are not passed to RHYME by whatever routine calls
 RHYME.
 No such notation appears in the LINE-IN-RHYME argument list, because ARG1
 and ARG2 are being passed to LINE-IN-RHYME.
 Note that LINE-IN-RHYME calls the variables ARG-A and ARG-B instead of
 ARG1 and ARG2; this is completely arbitrary.
 The writer of LINE-IN-RHYME could have called them ARG1 and ARG2 if he/she
 wished.
 Remember, even though the routine LINE-IN-RHYME only exists in one place
 in your game code, it can be called any number of times by other routines
 throughout your game code.
 In the case of the routine LINE-IN-RHYME above, it must be passed two arguments
 every time it is called.
\end_layout

\begin_layout Standard
There is a third type of argument, the optional argument.
 When an argument list contains such an argument, denoted by "OPT" in the
 argument list, it means that the routine accepts that passed argument,
 but it doesn't require it.
\end_layout

\begin_layout Standard
The three types of arguments must appear in the argument list in the following
 order: passed arguments, optional arguments, and auxiliary arguments (which
 are also known as local variables).
 A routine which uses all three kinds might look something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE CALLEE (X "OPT" Y "AUX" Z)
\end_layout

\begin_layout Plain Layout

    <some-stuff>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It could be called in either of two ways:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<CALLEE .FOO>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<CALLEE .FOO .BAR>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here's an example of a routine that takes an optional argument:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE OPEN-DOOR (DOOR "OPT" KEY)
\end_layout

\begin_layout Plain Layout

    <TELL "You open the " D .DOOR>
\end_layout

\begin_layout Plain Layout

    <COND (.KEY
\end_layout

\begin_layout Plain Layout

        <TELL " with the " D .KEY>)>
\end_layout

\begin_layout Plain Layout

    <TELL "." CR>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If this routine is called with <OPEN-DOOR ,OAK-DOOR> it will print "You
 open the oak door." If it is called with <OPEN-DOOR ,OAK-DOOR ,LARGE-RUSTYKEY>
 it will instead print "You open the oak door with the large rusty key."
\end_layout

\begin_layout Section
Conditionals
\end_layout

\begin_layout Standard
The guts of a routine are composed of things called CONDs, short for conditional
s.
 A COND is sort of an if-then statement.
 In its simplest form, it looks something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<if-this-is-true>
\end_layout

\begin_layout Plain Layout

       <then-do-this>)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The "if-this-is-true" section of the COND is called the predicate.
 A predicate is basically anything in ZIL whose value can be true or false.
 A bit later, we will look at the most common types of predicates.
\end_layout

\begin_layout Standard
A COND may have more than one predicate clause; if so, the COND will continue
 until one of the predicates proves to be true, and then skip any remaining
 predicate clauses:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<predicate-1>
\end_layout

\begin_layout Plain Layout

       <do-stuff-1>)
\end_layout

\begin_layout Plain Layout

      (<predicate-2>
\end_layout

\begin_layout Plain Layout

       <do-stuff-2>)
\end_layout

\begin_layout Plain Layout

      (<predicate-3>
\end_layout

\begin_layout Plain Layout

       <do-stuff-3>)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If <predicate-1> is true, then do-stuff-1 will occur, and the second and
 third clauses will be skipped.
 If <predicate-1> is false, the COND will then look at <predicate-2>, etc.
\end_layout

\begin_layout Standard
Often, a routine will have more than one COND:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<predicate-1>
\end_layout

\begin_layout Plain Layout

       <do-stuff-1>)>
\end_layout

\begin_layout Plain Layout

<COND (<predicate-2>
\end_layout

\begin_layout Plain Layout

       <do-stuff-2>)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this construction, the second predicate clause will happen even if the
 first predicate clause turned out to be true.
\end_layout

\begin_layout Section
Exiting a Routine
\end_layout

\begin_layout Standard
All routines return a value to the routine that called them.
 That value is the value of the last thing that the routine did.
 If that value is false, the routine is said to have returned false; if
 it returns any other value, the routine is said to have returned true:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE FIND-FOOD ("AUX" FOOD)
\end_layout

\begin_layout Plain Layout

    <COND (<IN? ,HAM-SANDWICH ,HERE>
\end_layout

\begin_layout Plain Layout

           <SET FOOD ,HAM-SANDWICH>)
\end_layout

\begin_layout Plain Layout

          (<IN? ,CANDY-BAR ,HERE>
\end_layout

\begin_layout Plain Layout

           <SET FOOD ,CANDY-BAR>)
\end_layout

\begin_layout Plain Layout

          (<IN? ,BELGIAN-ENDIVE ,HERE>
\end_layout

\begin_layout Plain Layout

           <SET FOOD ,BELGIAN-ENDIVE>)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <SET FOOD <>)>
\end_layout

\begin_layout Plain Layout

    .FOOD>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Remember, FOOD is an auxiliary local variable; its value is not passed to
 FINDFOOD by the calling routine.
 However, FIND-FOOD does return the value of FOOD back to the calling routine.
 If any of the three predicates are true, FINDFOOD will return the appropriate
 object, which means it has returned true.
 If the call to FIND-FOOD were a predicate, it would return true, as in:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<SET FOOD <FIND-FOOD>>
\end_layout

\begin_layout Plain Layout

       <REMOVE .FOOD>
\end_layout

\begin_layout Plain Layout

       <TELL "You eat the " D .FOOD
\end_layout

\begin_layout Plain Layout

             ", and your hunger abates." CR>)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If none of the three predicates in FIND-FOOD were true, then the value of
 .FOOD would be false, and the routine FIND-FOOD would return false.
 You can force a routine to return before reaching its end, by inserting
 <RTRUE> for "return true" or <RFALSE> for "return false" at any point in
 the routine.
 Note, however, that once the routine gets to this point, it will immediately
 stop executing, even if you haven't reached the bottom of the routine:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE STUPID-ROUTINE ()
\end_layout

\begin_layout Plain Layout

    <TELL "This is a stupidly-designed routine...">
\end_layout

\begin_layout Plain Layout

    <RTRUE>
\end_layout

\begin_layout Plain Layout

    <TELL "...because the RTRUE prevents it from
\end_layout

\begin_layout Plain Layout

           getting to this second string!" CR>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also force a routine to return a specific value, be it a string,
 an object, the value of a global variable, or the value of a local variable.
 For example, looking at two variations of FIND-FOOD:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<IN? ,CANDY-BAR ,HERE>
\end_layout

\begin_layout Plain Layout

       <RETURN ,CANDY-BAR>)>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<COND (<IN? ,CANDY-BAR ,HERE>
\end_layout

\begin_layout Plain Layout

       <RETURN "candy bar">)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first case returns the object named CANDY-BAR, the second returns the
 text string "candy bar." If you're confused about the significance of a
 routine returning a value, re-read this section after reading Chapter 5.
\end_layout

\begin_layout Section
ZIL Instructions
\end_layout

\begin_layout Standard
There are a number of things in ZIL code which, at first glance, look like
 calls to a routine.
 However, if you look for the associated routine in your game code, you
 won't find it anywhere.
 These are ZIL instructions, the method by which the game communicates with
 the interpreter that runs the game on each individual micro.
 ZIL instructions are sometimes referred to as op-codes.
\end_layout

\begin_layout Standard
You've already seen a few of the most common instructions, such as FCLEAR
 and SET.
 Some instructions, such as those, take one or more arguments:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<FCLEAR ,SEARCHLIGHT ,ONBIT>
\end_layout

\begin_layout Plain Layout

<SET .LAP-COUNTER 12>
\end_layout

\begin_layout Plain Layout

<RANDOM 100>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Others take no argument:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SAVE>
\end_layout

\begin_layout Plain Layout

<QUIT>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And, like routines, some instructions accept an optional argument.
 A complete list of the current ZIL instructions can be found in Appendix
 D.
\end_layout

\begin_layout Chapter
Simple Action Routines
\end_layout

\begin_layout Section
Simple Object Action Routines
\end_layout

\begin_layout Standard
Let's say you have an object AVOCADO with the property:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

(ACTION AVOCADO-F)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The routine called AVOCADO-F is the action routine for the object.
 It might look something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE AVOCADO-F ()
\end_layout

\begin_layout Plain Layout

    <COND (<VERB? EAT>
\end_layout

\begin_layout Plain Layout

           <REMOVE ,AVOCADO>
\end_layout

\begin_layout Plain Layout

           <TELL "The avocado is so delicious that you
\end_layout

\begin_layout Plain Layout

                  eat it all." CR>)
\end_layout

\begin_layout Plain Layout

          (<VERB? CUT OPEN>
\end_layout

\begin_layout Plain Layout

           <FSET ,AVOCADO ,OPENBIT>
\end_layout

\begin_layout Plain Layout

           <MOVE ,AVOCADO-PIT ,AVOCADO>
\end_layout

\begin_layout Plain Layout

           <TELL "You halve the avocado, revealing a
\end_layout

\begin_layout Plain Layout

                  gnarly pit." CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
AVOCADO-F, like most action routines, is not passed any arguments, and it
 uses none itself, so it has an empty argument list.
\end_layout

\begin_layout Standard
This routine demonstrates one of the simplest and commonest types of predicates.
 <VERB? EAT> is true if EAT is the PRSA identified by the parser.
 If the input was something like EAT THE AVOCADO or DEVOUR AVOCADO, the
 parser would set PRSA to the verb EAT, and <VERB? EAT> would be true.
 If so, the next two things would happen.
 The first is to REMOVE the avocado; that is, to set its LOC to false, since
 once it is eaten, it is now nowhere as far as the game is concerned.
 The second thing is the TELL.
 TELL is a kind of routine called a macro which is in charge of printing
 everything the user sees as output to his input.
 In its simplest use, as in this example, TELL simply takes the given string
 and prints it.
 The CR after the string means "carriage return," and causes one to occur
 after the string.
 CR will sometimes appear as the instruction <CRLF>, meaning "carriage return
 line feed." CR and CRLF have the same effect.
\end_layout

\begin_layout Standard
If EAT was the verb, this string is printed, the input has been handled,
 and the turn is essentially over.
 However, if EAT wasn't the verb, then the COND continues to the next predicate.
 This second predicate is true if the verb is either CUT or OPEN.
 In fact, the VERB? predicate can take any number of verbs to check.
\end_layout

\begin_layout Standard
If the second predicate is true, the first thing that happens is the FSET,
 which means "flag set." In this case, it gives the AVOCADO the OPENBIT flag.
 Note that an object either has the OPENBIT or it doesn't; there is no such
 thing as a CLOSEDBIT; the absence of the OPENBIT is enough to tell that
 the object is closed.
 If you wanted to get rid of the OPENBIT, or any other flag, you would use
 the FCLEAR operation.
 For example, if the player closed the iron gate, you'd probably have something
 like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<FCLEAR ,IRON-GATE ,OPENBIT>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Getting back to AVOCADO-F, the next thing that happens is to move the AVOCADO-PI
T object to the AVOCADO.
 This will set the AVOCADO pit's LOC to AVOCADO.
 Until this point, the pit probably had no LOC; that is, its LOC was false,
 meaning that as far as the game was concerned, it wasn't anywhere.
 Finally, the appropriate TELL is done.
 The input has now been handled.
 If neither of these predicates proves to be true, because the verb is something
 other than EAT, CUT, or OPEN, then AVOCADO-F has failed to handle the input.
 If AVOCADO was the PRSI, the PRSO routine will then be given the chance.
 If AVOCADO was the PRSO, the appropriate verb default will handle the input.
\end_layout

\begin_layout Section
Other Common Predicates
\end_layout

\begin_layout Standard
In addition to the VERB? predicate, let's look at some other common predicates.
 The most common one is EQUAL? as in:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<EQUAL? ,HERE ,DRAGONS-LAIR>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
HERE is a global variable which is always kept set to the current room.
 So, if the player was in the Dragon's Lair room, this predicate would be
 true; otherwise it would be false.
\end_layout

\begin_layout Standard
Many global variables (such as the CYCLOPS-FLED example in section 2.1) are
 just true-false variables.
 Such a global can be a predicate all by itself, without angle brackets:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

,CYCLOPS-FLED
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If CYCLOPS-FLED were currently true, the predicate would be true.
 Note the comma before the global.
 When writing ZIL code, all global variables, room names, and object names
 must be preceded by a comma.
 However, local variables, those defined in the argument list and appearing
 only in the current routine, must be preceded by a period.
 Such a local variable could similarly be used as a predicate:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE OTTO-F ("AUX" OTTO-TO-SANITORIUM)
\end_layout

\begin_layout Plain Layout

    <stuff-affecting-the-value-of-the-local-variable>
\end_layout

\begin_layout Plain Layout

    <COND (.OTTO-TO-SANITORIUM
\end_layout

\begin_layout Plain Layout

           <TELL "The van drives away, turning left
\end_layout

\begin_layout Plain Layout

                  toward Happy Dale." CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another common predicate is the FSET? predicate:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<FSET? ,AVOCADO ,OPENBIT>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will be true if the AVOCADO object has the OPENBIT flag set.
 Note the vastly important difference between FSET? and FSET — the first
 is a predicate, used to check whether a flag is set; the second is used
 to actually set the flag.
\end_layout

\begin_layout Standard
Another common predicate is IN? which checks the LOC of an object:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<IN? ,EGGS ,BASKET>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would be true if the LOC of the EGGS object was the BASKET object.
\end_layout

\begin_layout Standard
A routine can also be used as a predicate:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<IS-OTTO-ON-ELBA?>
\end_layout

\begin_layout Plain Layout

    <TELL "A telegram arrives from Uncle Otto,
\end_layout

\begin_layout Plain Layout

           complaining about his exile." CR>)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the routine IS-OTTO-ON-ELBA returned true, the predicate would be true,
 and vice versa.
 Here's what the routine might look like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE IS-OTTO-ON-ELBA? ()
\end_layout

\begin_layout Plain Layout

    <COND (<EQUAL? <LOC ,UNCLE-OTTO> ,PARIS ,WATERLOO>
\end_layout

\begin_layout Plain Layout

           <RFALSE>)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <RTRUE>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice that EQUAL? can take any number of arguments, which will be compared
 to the first thing after the EQUAL? The predicate will be true if any of
 the subsequent arguments have the same value as the second argument.
 Thus, the predicate in IS-OTTO-ON-ELBA? would be true if the LOC of the
 UNCLE-OTTO object was either PARIS or WATERLOO.
\end_layout

\begin_layout Standard

\emph on
[Put in something here about PDL's new P? predicate.]
\end_layout

\begin_layout Section
More Complicated Predicates
\end_layout

\begin_layout Standard
The predicates you've already learned can be combined with several fundamental
 ZIL operations to be more useful.
 One of these is NOT.
 NOT simply changes the sense of the predicate.
 If
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<FSET? ,TROPHY-CASE ,OPENBIT>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is false, because the trophy case is closed, then
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<NOT <FSET? ,TROPHY-CASE ,OPENBIT>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will be true.
 Once again, note the absence of a CLOSEDBIT.
 You check to see if the trophy case is closed by checking to make sure
 it doesn't have the OPENBIT.
\end_layout

\begin_layout Standard
Two or more simple predicates can be combined together using AND.
 In such a case, all of them must be true for the entire predicate to be
 true:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<AND <EQUAL? ,HERE ,LAUNDRY-ROOM>
\end_layout

\begin_layout Plain Layout

     <FSET? ,DRYER ,ONBIT>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This predicate will only be true if the player is in the laundry room and
 the dryer is on.
 If either part is false, the entire predicate will be false.
 Similarly, two or more simple predicates can be combined using OR.
 In that case, the entire predicate is true if any of the parts are true:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<OR <IN? ,SABOTEUR ,ZEPELLIN>
\end_layout

\begin_layout Plain Layout

    ,BOMB-DEFUSED
\end_layout

\begin_layout Plain Layout

    <EQUAL? ,BLIMP-DESTINATION ,NEW-JERSEY>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This predicate will be true if the SABOTEUR object is in the ZEPELLIN object,
 or if the global variable BOMB-DEFUSED is set to true, or if the global
 variable called BLIMP-DESTINATION is set to NEW-JERSEY.
 Of course, if two or more of the parts are true, the entire predicate remains
 true.
 Only if all three parts are false will this predicate be false.
\end_layout

\begin_layout Standard
As you can surmise, all sorts of hair-raisingly complicated predicates can
 be strung together using AND, OR and NOT.
 Here's what a more complicated version of AVOCADO-F might look like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE AVOCADO-F ()
\end_layout

\begin_layout Plain Layout

    <COND (<VERB? EAT>
\end_layout

\begin_layout Plain Layout

           <COND (,AVOCADO-POISONED
\end_layout

\begin_layout Plain Layout

                  <SETG PLAYER-POISONED T>
\end_layout

\begin_layout Plain Layout

                  <REMOVE ,AVOCADO>
\end_layout

\begin_layout Plain Layout

                  <TELL "You begin to feel sick." CR>)
\end_layout

\begin_layout Plain Layout

                 (<AND <EQUAL? ,HERE ,GARDEN-OF-EDEN>
\end_layout

\begin_layout Plain Layout

                     <IN? ,SNAKE ,TREE-OF-KNOWLEDGE>>
\end_layout

\begin_layout Plain Layout

                  <MOVE ,APPLE ,HERE>
\end_layout

\begin_layout Plain Layout

                  <TELL "The avocado is so
\end_layout

\begin_layout Plain Layout

unappetizing.
 Suddenly, a seductive voice beckons from
\end_layout

\begin_layout Plain Layout

the tree.
 A moment later, a succulent apple lands at
\end_layout

\begin_layout Plain Layout

your feet." CR>)
\end_layout

\begin_layout Plain Layout

                 (T
\end_layout

\begin_layout Plain Layout

                  <REMOVE ,AVOCADO>
\end_layout

\begin_layout Plain Layout

                  <MOVE ,AVOCADO-PIT ,PLAYER>
\end_layout

\begin_layout Plain Layout

                  <TELL "You eat the entire avocado.
\end_layout

\begin_layout Plain Layout

                         It was filling, if not tasty." CR>)>)
\end_layout

\begin_layout Plain Layout

          (<AND <VERB? THROW>
\end_layout

\begin_layout Plain Layout

                <EQUAL? ,HERE ,MIDWAY>
\end_layout

\begin_layout Plain Layout

                <NOT ,BALLOON-POPPED>
\end_layout

\begin_layout Plain Layout

                <HAWKER-AT-CIRCUS>>
\end_layout

\begin_layout Plain Layout

           <MOVE ,AVOCADO ,MIDWAY-BOOTH>
\end_layout

\begin_layout Plain Layout

           <TELL "The avocado bounces off the balloon.
\end_layout

\begin_layout Plain Layout

The hawker sneers.
 
\backslash
"You'd have more luck with a dart,
\end_layout

\begin_layout Plain Layout

kiddo! Only two bits!
\backslash
"" CR>)
\end_layout

\begin_layout Plain Layout

          (<AND <VERB? COOK>
\end_layout

\begin_layout Plain Layout

                <OR <NOT <EQUAL? ,HERE ,KITCHEN>>
\end_layout

\begin_layout Plain Layout

                    <NOT <IN? ,COOKPOT ,OVEN>>>>
\end_layout

\begin_layout Plain Layout

           <TELL "Even a master chef couldn't cook an
\end_layout

\begin_layout Plain Layout

                  avocado with what you've got!" CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note some things about the above routine that are new to you.
 The first is the inner COND, which appears within the <VERB? EAT> clause
 of the main COND.
 Such nesting can continue more and more deeply without limit (other than
 the ability for people looking at the code to understand the resulting
 routine).
\end_layout

\begin_layout Standard
The second thing to note is the last predicate in that inner COND: it is
 simply a T.
 This is simply a predicate that is always true.
 The result in this case is that AVOCADO-F should always handle the input
 EAT AVOCADO.
 If the verb is EAT, the inner COND will check the first and second predicates.
 If neither is true, then the third clause, the one with the T predicate,
 will occur in all cases.
 Sometimes you'll see ELSE instead of T; these mean the same thing.
\end_layout

\begin_layout Standard
The third thing is the string in the second TELL, where the hawker speaks.
 Note the backslash before the hawker's quotes.
 These are necessary anytime you have quotes within a string; without the
 backslash, the compiler will think the quote means the end of the string
 rather than a character within the string, and get very confused.
 A confused compiler is not a pretty sight.
\end_layout

\begin_layout Section
A Room's Action Routine
\end_layout

\begin_layout Standard
A room's action routine is (generally) not used for the purpose of handling
 the player's input directly, as with an object's action routine.
 These routines perform a wide range of tasks.
 All room action routines are passed an argument, which tell the routine
 for what purpose it is being called.
 By convention, this argument is called RARG (for room argument).
\end_layout

\begin_layout Standard
The most common use of a room's action routine is for the purpose of describing
 the room (due to a LOOK or due to entering the room for the first time,
 or due to entering the room in verbose mode).
 If a room's description never changes, it can have an LDESC property, a
 string which is the room's unchanging description.
 More often than not, however, the room's description changes (a door closes,
 a roof collapses, a window gets broken, a tree gets chopped down...) and in
 these cases the room's action routine must handle the description.
 In this case, the action routine is called with an argument called M-LOOK:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE CAFETERIA-F (RARG)
\end_layout

\begin_layout Plain Layout

<COND (<EQUAL? .RARG ,M-LOOK>
\end_layout

\begin_layout Plain Layout

       <TELL "This is a lunch room, with windows overlooking a
\end_layout

\begin_layout Plain Layout

              loading dock.
 ">
\end_layout

\begin_layout Plain Layout

       <COND (<IN? LUNCH-CROWD ,CAFETERIA>
\end_layout

\begin_layout Plain Layout

              <TELL "Every table is jammed with patrons.
 ">)>
\end_layout

\begin_layout Plain Layout

       <TELL "The only exit is north." CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice how the room description changes, depending on whether or not the
 LUNCH-CROWD object is in the cafeteria.
 Also, notice the argument list with RARG.
 Finally, notice that the RARG in the predicate has a period in front of
 it; this is because it is a local variable in CAFETERIA-F.
 (It's okay for any number of routines to have a local variable with the
 same name; but every global variable, object, etc.
 must have a unique name.)
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Another reason for calling a room's action routine is to print a message
 or perform some operation upon entering it.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>NORTH
\end_layout

\begin_layout Plain Layout

Upon entering the crypt, a cold icy wind cuts through
\end_layout

\begin_layout Plain Layout

you, and you realize that the dreaded poltergeist is
\end_layout

\begin_layout Plain Layout

near!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Crypt
\end_layout

\begin_layout Plain Layout

This is a spooky room...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The phrase "Upon entering the crypt..." is probably being TELLed by an action
 routine that looks something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE CRYPT-F (RARG)
\end_layout

\begin_layout Plain Layout

    <COND (<EQUAL? .RARG ,M-ENTER>
\end_layout

\begin_layout Plain Layout

           <MOVE ,POLTERGEIST ,HERE>
\end_layout

\begin_layout Plain Layout

           <TELL
\end_layout

\begin_layout Plain Layout

"Upon entering the crypt, a cold icy wind cuts through
\end_layout

\begin_layout Plain Layout

you, and you realize that the dreaded poltergeist is
\end_layout

\begin_layout Plain Layout

near!" CR CR>)
\end_layout

\begin_layout Plain Layout

          (<EQUAL? .RARG ,M-LOOK>
\end_layout

\begin_layout Plain Layout

           <TELL "This is a spooky room..." CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are two CRs after the M-ENTER TELL in order to create a blank line
 between it and the room name.
\end_layout

\begin_layout Standard
Very often, an M-ENTER clause just does some stuff invisibly:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE HAUNTED-PANTRY (RARG)
\end_layout

\begin_layout Plain Layout

    <COND (<EQUAL? .RARG ,M-ENTER>
\end_layout

\begin_layout Plain Layout

           <MOVE ,SKELETON ,HERE>
\end_layout

\begin_layout Plain Layout

           <SETG SKELETON-SCARE T>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This M-ENTER moves the SKELETON object into the pantry, and sets a global
 variable called SKELETON-SCARE to T.
 (The SETG command, for set global, is used to change the value of any global
 variable.
 Local variables are set with SET instead.)
\end_layout

\begin_layout Standard
There are several more uses of a room's action routine, but you're still
 too young and tender to hear about them.
 Besides, it's time for...
\end_layout

\begin_layout Section*
EXERCISE ONE
\end_layout

\begin_layout Standard
Using what you've learned so far, write a room definition, an object definition,
 and an action routine for that object.
 Then find a friendly imp (if possible) and have him or her critique it.
\end_layout

\begin_layout Chapter
Events
\end_layout

\begin_layout Section
Definition
\end_layout

\begin_layout Standard
Not all text that appears in an IF game is in response to the player's input.
 Some text is the result of an event — the lamp burning out, an earthquake,
 the arrival of a murder suspect, etc.
 Such events are called interrupts.
\end_layout

\begin_layout Standard
The convention for naming an interrupt routine is to prefix it with "I-"
 as in I-GUNSHOT.
 Here's an example of what a simple interrupt might look like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE I-OTTO-GOES-NUTS ()
\end_layout

\begin_layout Plain Layout

    <FSET ,UNCLE-OTTO ,LOONEYBIT>
\end_layout

\begin_layout Plain Layout

    <COND (<IN? ,UNCLE-OTTO ,HERE>
\end_layout

\begin_layout Plain Layout

           <TELL
\end_layout

\begin_layout Plain Layout

              "Sigh; it appears that Uncle Otto's delusion has
\end_layout

\begin_layout Plain Layout

               returned; he has begun shouting orders to unseen
\end_layout

\begin_layout Plain Layout

               troops." CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Section
How The Interrupt System Works
\end_layout

\begin_layout Standard
During most turns, time passes within the story.
 The exceptions are parser failures, and certain game commands such as SCRIPT
 or VERBOSE.
 At the conclusion of each turn in which time has advanced, after the player's
 input has been handled, a routine called CLOCKER runs.
 This routine "counts down" all the interrupt routines that are queued to
 run; if a given routine's time has come, CLOCKER calls that routine.
\end_layout

\begin_layout Standard
Any interrupt which does a TELL should return true; any interrupt that doesn't
 should return false.
 This is for the benefit of the verb WAIT, which causes several turns to
 pass.
 Interrupts must terminate a WAIT in order to prevent this kind of thing:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>WAIT
\end_layout

\begin_layout Plain Layout

Time passes...
\end_layout

\begin_layout Plain Layout

    A truck begins speeding toward you.
\end_layout

\begin_layout Plain Layout

    The truck loudly honks its horn.
\end_layout

\begin_layout Plain Layout

    Since you refuse to move out of the way, the truck
\end_layout

\begin_layout Plain Layout

merges you into the pavement.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only way for CLOCKER to tell V-WAIT to stop running is for the interrupt
 routine to RTRUE, meaning, "I've done a TELL." In the reverse case, if an
 interrupt runs and RTRUEs but fails to TELL anything, the WAIT will terminate
 early, but for no apparent reason.
\end_layout

\begin_layout Section
Queuing an Interrupt Routine
\end_layout

\begin_layout Standard
An interrupt routine is queued by you, the writer, at some point.
 It might be at the beginning of the game, or it might be in response to
 something the player did.
 One interrupt routine might queue a subsequent interrupt routine.
 It is done using the routine QUEUE, which takes the name of the interrupt
 routine, and a number to indicate the number of turns from now you'd like
 the interrupt to run:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<QUEUE I-SHOOTING-STAR 10>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ten turns from now, the interrupt routine called I-SHOOTING-STAR will be
 called by CLOCKER, and will do whatever it is set up to do.
 An interrupt routine which is queued to 1 will run on the same turn, before
 the very next prompt.
 An interrupt which is queued to 2 will run after the following turn, and
 so forth.
\end_layout

\begin_layout Standard
An interrupt runs only once, and then isn't heard from again unless you
 requeue it.
 However, there is one important exception: if you queue an interrupt to
 -1, the interrupt will run every turn from then on, until you dequeue it.
\end_layout

\begin_layout Standard
A routine is dequeued simply by saying <DEQUEUE I-WHATEVER>.
\end_layout

\begin_layout Standard
An example of a routine queued to -1 would be the truck interrupt which
 was used as an example in section 4.2.
 In conjunction with a global variable called TRUCK-COUNTER, initially set
 to a value of zero, the routine might look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE I-TRUCK ()
\end_layout

\begin_layout Plain Layout

    <SETG TRUCK-COUNTER <+ ,TRUCK-COUNTER 1>>
\end_layout

\begin_layout Plain Layout

    <COND (<EQUAL? ,TRUCK-COUNTER 1>
\end_layout

\begin_layout Plain Layout

           <MOVE ,TRUCK ,STREET>
\end_layout

\begin_layout Plain Layout

           <TELL
\end_layout

\begin_layout Plain Layout

"A truck begins speeding toward you." CR>)
\end_layout

\begin_layout Plain Layout

          (<EQUAL? ,TRUCK-COUNTER 2>
\end_layout

\begin_layout Plain Layout

           <TELL
\end_layout

\begin_layout Plain Layout

"The truck loudly honks its horn." CR>)
\end_layout

\begin_layout Plain Layout

          (<EQUAL? ,TRUCK-COUNTER 3>
\end_layout

\begin_layout Plain Layout

           <COND (<EQUAL? ,HERE ,STREET>
\end_layout

\begin_layout Plain Layout

                  <JIGS-UP
\end_layout

\begin_layout Plain Layout

"Since you refuse to move out of the way, the truck
\end_layout

\begin_layout Plain Layout

merges you into the pavement.">)
\end_layout

\begin_layout Plain Layout

                 (T ;"you've gotten out of the way"
\end_layout

\begin_layout Plain Layout

                  <TELL
\end_layout

\begin_layout Plain Layout

"The truck blasts you with hot exhaust fumes as it
\end_layout

\begin_layout Plain Layout

rumbles past." CR>)
\end_layout

\begin_layout Plain Layout

          (T ;"counter is 4"
\end_layout

\begin_layout Plain Layout

           <DEQUEUE I-TRUCK>
\end_layout

\begin_layout Plain Layout

           <SETG TRUCK-COUNTER 0>
\end_layout

\begin_layout Plain Layout

           <TELL
\end_layout

\begin_layout Plain Layout

"The truck vanishes in the direction of Hoboken."
\end_layout

\begin_layout Plain Layout

CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice the first item, where 1 is added to the value of TRUCK-COUNTER.
 This enables I-TRUCK to "know" how far through the truck sequence it is.
\end_layout

\begin_layout Standard
Also, notice the routine called JIGS-UP, which is being passed a string
 as an argument.
 This notorious routine is the routine which "kills" the player; it prints
 the string which gets passed to it, followed by something like "*** You
 have died ***." The JIGS-UP occurs only if the player remains in the street.
 Otherwise, the second part of that COND occurs, with the text about the
 truck rumbling (safely) past.
\end_layout

\begin_layout Standard
Finally, notice that the last predicate in the main COND is simply T.
 This is a predicate which is always true; anytime the COND reaches that
 point, the stuff in that clause will be executed.
 In this case, that will happen whenever TRUCK-COUNTER is 4.
 In addition to turning itself off using DEQUEUE, notice that TRUCK-COUNTER
 is also set to 0.
 This is so that if and when I-TRUCK runs at some future point in the game,
 it will act properly.
\end_layout

\begin_layout Standard
Note the semi-coloned messages next to the two "T" predicates.
 These are called comments.
 Anything preceded by a semi-colon is ignored by the compiler when it comes
 time to compile your ZIL code.
 Therefore, comments like these can be placed anywhere to annotate your
 code but without interfering with it.
 You can also put a semi-colon in front of a routine or part of a routine,
 if you wish to remove it for now, but keep it around in case you decide
 to use it again in the future.
 This is called "commenting out" code.
\end_layout

\begin_layout Section
Room M-ENDs
\end_layout

\begin_layout Standard
A simple way for an event to occur is by having an M-END clause in the room's
 action routine.
 At the end of every turn (but before CLOCKER is called) the current room's
 action routine is automatically called with the argument M-END.
 An M-END differs from an interrupt in that it cannot be queued, it can
 only be based on current conditions; further, it is limited to one room.
 Here's an example of an action routine with an M-END which is basically
 just for atmosphere:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE AIRPORT-F (RARG)
\end_layout

\begin_layout Plain Layout

    <COND (<EQUAL? .RARG ,M-ENTER>
\end_layout

\begin_layout Plain Layout

           <QUEUE I-STRAFING 5>)
\end_layout

\begin_layout Plain Layout

          (<EQUAL? .RARG ,M-LOOK>
\end_layout

\begin_layout Plain Layout

           <TELL
\end_layout

\begin_layout Plain Layout

"You are on the tarmac of an airport runway..." CR>)
\end_layout

\begin_layout Plain Layout

          (<EQUAL? .RARG ,M-END>
\end_layout

\begin_layout Plain Layout

           <TELL "A plane zooms low overhead." CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternatively, an M-END can be more of an event:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE AIRPORT-F (RARG)
\end_layout

\begin_layout Plain Layout

    <COND (<AND <EQUAL? .RARG ,M-END>
\end_layout

\begin_layout Plain Layout

                ,BATTLE-BEGUN>
\end_layout

\begin_layout Plain Layout

           <JIGS-UP
\end_layout

\begin_layout Plain Layout

"The shadow of a bomber sweeps across the airfield.
 The
\end_layout

\begin_layout Plain Layout

tarmac where you were standing is now a giant hole, and
\end_layout

\begin_layout Plain Layout

you are now tiny bits of exploded flesh.">)>>
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Let's Learn a Whole Lot More About ZIL Code
\begin_inset Argument 1
status open

\begin_layout Plain Layout
More About ZIL Code
\end_layout

\end_inset


\end_layout

\begin_layout Section
Mathematical Expressions in ZIL
\end_layout

\begin_layout Standard
ZIL uses an arithmetic notation called prefix notation.
 In this form of notation, the operator (+ or - or * or /) comes before
 the operands, rather than between them.
 
\end_layout

\begin_layout Standard
For example if you wanted to add 4 and 7, it would look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<+ 4 7>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And if you wanted to subtract 10 from 50, it would look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<- 50 10>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Multiplication and division, though rarely used in game code, look thus:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<* 5 12>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

</ 20 4>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For a more complicated example, let's look at (10 + 5) * (26/2 -5) in prefix
 notation:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<* <+ 10 5> <- </ 26 2> 5>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pay close atttention to the balancing of the angle brackets.
\end_layout

\begin_layout Standard
Most of the time, in game code, you'll be performing arithmetic operations
 on variables and routines, rather than numbers.
 For example, to subtract 10 from a global variable called SPACESHIP-TEMP,
 which is keeping track of how cold it's getting in your leaking spacecraft:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SETG SPACESHIP-TEMP <- ,SPACESHIP-TEMP 10>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If there were a routine called POPULATION which took a room and returned
 the number of people there, you might see an expression like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<EQUAL? <+ <POPULATION ,BAR>
\end_layout

\begin_layout Plain Layout

                  <POPULATION ,RESTAURANT>
\end_layout

\begin_layout Plain Layout

                  <POPULATION ,COFFEE-SHOP>> 101>
\end_layout

\begin_layout Plain Layout

       <MOVE ,POLICEMAN ,RESTAURANT>
\end_layout

\begin_layout Plain Layout

       <TELL
\end_layout

\begin_layout Plain Layout

"A policeman shows up, loudly blowing his whistle.
\end_layout

\begin_layout Plain Layout


\backslash
"Occupancy by more than 100 persons is unlawful and
\end_layout

\begin_layout Plain Layout

hazardous!
\backslash
" he shouts." CR>)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Actually, in this last example, <EQUAL? ...
 101> would probably want to be <G? ...
 100> since if the three populations added up to 103 or 154, you'd want
 the policeman to show up.
 G? is a predicate meaning "greater than," and takes two arguments.
 The predicate will be true if the first thing is greater than the second
 thing.
 There is, of course, a L? predicate for "less than."
\end_layout

\begin_layout Standard
A final note: ZIL can only deal with integers (anywhere in the range from
 -32767 to 32767).
 You cannot use a non-integer value, such as 7.5 or 3.625.
\end_layout

\begin_layout Standard
There is a useful instruction in ZIL called MOD.
 It takes two values, and returns the remainder of dividing the first value
 by the second value.
 Example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<MOD ,FAT-LADYS-WEIGHT 10>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the global variable FAT-LADYS-WEIGHT was currently 425, then this MOD
 would return 5 (425 divided by 10 is 42 with a remainder of 5).
 If FAT-LADYS-WEIGHT were instead 420, then this MOD would have a value
 of 0.
 MOD is useful because ZIL can only do integers.
 Normally, if you divide 425 by 10, you get 42, and the remainder is essentially
 thrown away; if you need to save the remainder of a division for some reason,
 the only way to do so is with MOD.
\end_layout

\begin_layout Section
Global Variables
\end_layout

\begin_layout Standard
We have already seen global variables and a number of their uses — for example,
 CYCLOPS-FLED from back in section 2.2.
 Recapping, globals are the primary method of storing information about
 the state of the game's universe.
 Their value is changed by the game code whenever appropriate, using SETG
 (for "set global").
 If there were a global called PIZZAS-EATEN, then it might be changed in
 your code as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<TELL "You swallow another pizza." CR>
\end_layout

\begin_layout Plain Layout

<SETG PIZZA-EATEN <+ ,PIZZA-EATEN 1>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In other words, add 1 to the current value of the global; if it's currently
 5, make it 6, for example.
 The values of globals stay the same until your code changes them — or until
 the player restarts the game, at which point they would resume their initial
 values.
\end_layout

\begin_layout Standard
When you decide to create a global variable, first you must define it.
 This definition should look something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<GLOBAL GLOBAL-NAME INITIAL-VALUE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This definition should not have a comma before the global name.
 The definition can go anywhere at top level; that is, it can go anywhere
 at all in your code, but not inside a routine or object definition.
 (With very few exceptions, any routine, global definition, or object definition
 can go anywhere at top level; however, it's good form to keep related items
 grouped together.) Here are some examples of typical global definitions.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<GLOBAL SECRET-PASSAGE-OPENED <>>
\end_layout

\begin_layout Plain Layout

<GLOBAL SLEEPY T>
\end_layout

\begin_layout Plain Layout

<GLOBAL FUSE-COUNTER 0>
\end_layout

\begin_layout Plain Layout

<GLOBAL NUMBER-OF-MATCHES 5>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first two globals are used simply as true-false indicator.
 (Such a global, which is either true or false, is sometimes referred to
 as a "flag." This shouldn't be confused with FLAGS such as TAKEBIT and RLANDBIT.)
 The first one, SECRET-PASSAGE-OPENED, is being defined with an initial
 value of false (<> means false) because, at the beginning of the game,
 the secret passage is closed.
 The second one, SLEEPY, is being defined with an initial value of T, presumably
 because the player begins the game in a tired state.
 Globals can also be used to hold a numerical value, like the third and
 fourth examples.
 Global variables can also be set to objects, rooms, strings, and even routines.
 For example, the global HERE is always set to the player's current room.
 However, it sometimes causes the compiler confusion to define a global's
 value as an object; it's safer to say: 
\emph on
[is this still true?]
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<GLOBAL HERE <>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and then early in the game, such as in the startup routine (which is always
 called GO), you can say:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SETG HERE ,FRONT-PORCH>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where the FRONT-PORCH room is the opening room of the game.
 Globals are one of the few things in the ZIL environment that you may run
 short of; a maximum of only 240 are allowed in the entire game (although,
 if you do run short, there are some tricks...)
\end_layout

\begin_layout Section
The Containment System
\end_layout

\begin_layout Standard
This has nothing to do with nuclear power plants or with halting the spread
 of Communism.
 It is the inter-related system of object locations which is one of the
 pillars of ZIL.
\end_layout

\begin_layout Standard
As you'll recall, every object in ZIL has a LOC.
 All rooms are located in a special object called ROOMS.
 Objects are located "on the ground" of rooms, or inside other objects.
 Some objects might not have any LOC at a given point in time; their LOC
 is false.
\end_layout

\begin_layout Standard
The containment system determines a number of very important things.
 One of these is whether a given object is referenceable.
 Remember, the parser identifies a PRSO and PRSI; to be identified by the
 parser, an object must be present and visible (unless the verb is a special
 one, like FOLLOW, where the PRSO isn't required to be present).
\end_layout

\begin_layout Standard
For example, if an object isn't in the same room as the player, or the object
 is present but inside a closed container, or if the object has its INVISIBLE
 flag set, the object won't be currently referenceable.
 If the player refers to it in his or her input, the parser will fail, respondin
g "You can't see [that] here!"
\end_layout

\begin_layout Standard
To produce the location of an object, you simply say:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<LOC ,OBJECT-NAME>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For example, you might have a predicate like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<EQUAL? <LOC ,HORSE> ,STABLE ,BARN ,LARRYS-BEDROOM>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which would be true if the LOC of the horse was any of those three rooms.
 You could also use LOC like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SETG GLOWING-ROOM <LOC ,LEAKY-NUCLEAR-WASTE-DRUM>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also use IN? as a predicate to check the LOC of an object:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<IN? ,PICKLE ,BARREL>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would be true if the BARREL object was the LOC of the PICKLE object.
 Note that IN? takes only two arguments, an object and a possible location.
 You cannot give several possible locations, as in <IN? ,PICKLE ,BARREL
 ,JAR>; you would have to use an EQUAL? construct like the HORSE example
 a few lines back.
\end_layout

\begin_layout Standard
You change the LOC of an object using MOVE:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<MOVE ,HORSE ,STABLE>
\end_layout

\begin_layout Plain Layout

<TELL "The horse gallops off toward the stable." CR>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Whatever the LOC of the horse was before, it will now be the stable.
 There's no harm done if the horse's LOC was already the stable.
 If you want to "get rid" of an object, you REMOVE it:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<REMOVE ,HORSE>
\end_layout

\begin_layout Plain Layout

<MOVE ,GLUE ,OUTPUT-HOPPER>
\end_layout

\begin_layout Plain Layout

<TELL
\end_layout

\begin_layout Plain Layout

"The horse obediently limps into the glue machine,
\end_layout

\begin_layout Plain Layout

which shakes and rattles for a minute.
 Suddenly, the
\end_layout

\begin_layout Plain Layout

machine becomes still, and a bottle of glue appears in
\end_layout

\begin_layout Plain Layout

the output hopper." CR>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Working the other way, to find the contents of a given object, you need
 two commands, FIRST? and NEXT?.
 Let's say you had an object called KITCHEN-CABINET, which contained a pitcher,
 a serving spoon, and a severed head:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<FIRST? ,KITCHEN-CABINET>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would return the object PITCHER.
 Then
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<NEXT? ,PITCHER>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would be the serving spoon, whose NEXT? would be the severed head.
 Since the severed head is the last object contained by the cabinet, then
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<NEXT? ,SEVERED-HEAD>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would, by definition, be false.
 FIRST? or NEXT? can be used as a predicate:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<AND <VERB? SHAKE>
\end_layout

\begin_layout Plain Layout

            <FIRST? ,PRSO>>
\end_layout

\begin_layout Plain Layout

       <TELL
\end_layout

\begin_layout Plain Layout

"You hear something rattling around inside " D ,PRSO
\end_layout

\begin_layout Plain Layout

"." CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Section
Globals and Local-Globals
\end_layout

\begin_layout Standard
Now we're going to discuss global objects.
 Don't confuse this with global variables, discussed earlier in section
 7.2.
 A global variable is a variable whose value can be used anywhere in your
 ZIL code; a global object is an object which can be referenced by the player
 anywhere in the game.
\end_layout

\begin_layout Standard
Some objects can be referenced at all times, in all locations.
 For example, an AIR or GROUND object, or body parts such as the HANDS object.
 Such objects are called global objects.
 There is a special object, like the ROOMS object, called GLOBAL-OBJECTS;
 in order to make an object referencable at any time, define it with (LOC
 GLOBAL-OBJECTS).
\end_layout

\begin_layout Standard
Similarly, there is an object called GENERIC-OBJECTS.
 Concept-objects, such as the MURDER or NEW-WILL objects in Deadline, belong
 there.
 These objects can be talked about, but not seen or touched.
\end_layout

\begin_layout Standard
There's another class of objects, which are referenceable in more than one
 location, but not in all locations.
 A classic example is a door, which is in the two rooms on either side of
 the door, but not in any other rooms.
 Other examples are things like WATER, TREES, or STAIRS.
 Such objects are called local-globals and are "stored" in another one of
 those special objects, called LOCAL-GLOBALS.
 The definition of a local-global might look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<OBJECT RIVER-BANK
\end_layout

\begin_layout Plain Layout

    (LOC LOCAL-GLOBALS)
\end_layout

\begin_layout Plain Layout

    (DESC "river bank")
\end_layout

\begin_layout Plain Layout

    etc...>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But that's not enough.
 You also need to tell the game what subset of rooms this local-global is
 referenceable in.
 You do this using the GLOBAL property.
 (Remember it from the LIVING-ROOM definition way back in section 2.1?) The
 GLOBAL property tells the parser all the local-globals that are referenceable
 in each room.
 In the RIVER-BANK example, the room definitions for the rooms called LEFT-BANK
 and RIGHT-BANK would each need a line:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

(GLOBAL RIVER-BANK)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A GLOBAL property can contain any number of objects (well, up to 31, anyway):
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

(GLOBAL RIVER-BANK RIVER TREE EIFFEL-TOWER KIOSK)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are some semi-obvious restrictions on globals and local-globals.
 They can never be takeable.
 They cannot be containers; if you had a wastebasket local-global on a number
 of street corners, and the player threw a Big Mac wrapper in it at one
 location, the wrapper would be sitting in the wastebasket at every corner!
 Similar problem with having a global or local-global which you can turn
 on to produce light, etc.
\end_layout

\begin_layout Section
The Full Glory of TELL
\end_layout

\begin_layout Standard
It's time to learn the full power of the TELL.
 Remember how important TELL is: almost every single character of text output
 that appears on the player's screen does so through the use of TELL.
\end_layout

\begin_layout Standard
TELL prints text that is given to it in a number of different forms.
 The most common form is a string:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<TELL "This is just a plain old string.">
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also give TELL the name of a global whose value is a string.
 For example if you defined a global thusly:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<GLOBAL CANT-SEE-ANY "You can't see any ">
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or if you set a GLOBAL thusly:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SETG CANT-SEE-ANY "You can't see any ">
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then you could use it in a TELL thusly:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<TELL ,CANT-SEE-ANY "rainbow here." CR>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which would appear in the game's output as "You can't see any rainbow here."
 You can also give TELL a call to a routine which returns a string.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE PICK-STRING (OBJ)
\end_layout

\begin_layout Plain Layout

    <COND (<EQUAL? .OBJ ,DRAGON>
\end_layout

\begin_layout Plain Layout

           <RETURN "nasty">)
\end_layout

\begin_layout Plain Layout

          (<EQUAL? .OBJ ,FOX>
\end_layout

\begin_layout Plain Layout

           <RETURN "sly">)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <RETURN "hungry">)>
\end_layout

\begin_layout Plain Layout

<TELL "The animal looks very " <PICK-STRING ,PRSO> "." CR>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Very often you want TELL to print the DESC of a room or object.
 To do this, you would include D ,OBJECT-NAME.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<TELL "The " D ,LARGE-KEY " doesn't fit the tiny lock."
\end_layout

\begin_layout Plain Layout

CR>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the DESC of the LARGE-KEY object was "large key" then this TELL would
 produce "The large key doesn't fit the tiny lock." You can also use D ,GLOBAL-VA
RIABLE when the global variable in question is set to a room or object.
 This is very commonly done with the global variables PRSI and PRSO.
 For example, the V-EAT verb default often looks like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE V-EAT ()
\end_layout

\begin_layout Plain Layout

    <TELL "I doubt the " D ,PRSO " would agree with you." CR>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the direct object of the input was the SWORD object, the parser would
 set PRSO to SWORD.
 If the SWORD had (DESC "elvish sword") then V-EAT would print "I doubt
 the elvish sword would agree with you."
\end_layout

\begin_layout Standard
In these examples, D is called a tell token.
 Most games have a number of tell tokens in addition to D; the writer can
 add them, but don't worry now about how to do so.
 Two of the most common tell tokens are A and T.
 These are used in conjunction with two flags called the VOWELBIT and the
 NARTICLEBIT.
\end_layout

\begin_layout Standard
T ,OBJECT-NAME means that TELL should print a space followed by the word
 "the" followed by another space followed by the object's DESC.
 Using the T tell token, the V-EAT from above would look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE V-EAT ()
\end_layout

\begin_layout Plain Layout

    <TELL
\end_layout

\begin_layout Plain Layout

"I doubt" T ,PRSO " would agree with you." CR>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, if an object has a FLAG called the NARTICLEBIT, the T tell token
 knows not to print "the" before the DESC.
 For example, if an object called CROWDS had a DESC "lots of people" then
 you'd want V-EAT to print "I doubt lots of people would agree with you."
 rather than "I doubt the lots of people would agree with you."
\end_layout

\begin_layout Standard
The tell token A does the same thing as the tell token T except, of course,
 printing the indefinite article ("a") rather than the definite article
 ("the").
 The A tell token has one additional wrinkle, though; it checks whether
 the object in question has a FLAG called the VOWELBIT to decide whether
 to print "a" or "an" before the DESC.
 Here's a TELL and how it would handle three different object DESC's:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<TELL "It looks just like" A ,PRSO "." CR>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<OBJECT TEA-BAG
\end_layout

\begin_layout Plain Layout

(DESC "tea bag")
\end_layout

\begin_layout Plain Layout

(FLAGS TAKEBIT)
\end_layout

\begin_layout Plain Layout

etc...>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>EXAMINE TEA BAG
\end_layout

\begin_layout Plain Layout

It looks just like a tea bag.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<OBJECT APPLE
\end_layout

\begin_layout Plain Layout

(DESC "apple")
\end_layout

\begin_layout Plain Layout

(FLAGS TAKEBIT VOWELBIT)
\end_layout

\begin_layout Plain Layout

etc...>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>EXAMINE APPLE
\end_layout

\begin_layout Plain Layout

It looks just like an apple.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<OBJECT VERMICELLI
\end_layout

\begin_layout Plain Layout

(DESC "vermicelli")
\end_layout

\begin_layout Plain Layout

(FLAGS TAKEBIT NARTICLEBIT)
\end_layout

\begin_layout Plain Layout

etc...>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>EXAMINE VERMICELLI
\end_layout

\begin_layout Plain Layout

It looks just like vermicelli.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you want TELL to print something whose value is a number, use the tell
 token N.
 For example if a global variable called DIAL-SETTING was currently set
 to 94, then
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<TELL "The dial is currently set to " N ,DIAL-SETTING
\end_layout

\begin_layout Plain Layout

"." CR>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would print "The dial is currently set to 94."
\end_layout

\begin_layout Standard
Finally, TELLs can do carriage returns.
 A carriage return puts the text output point at the beginning of the next
 line.
 You can have TELL do a carriage return by putting CR outside of a string,
 or a vertical bar (upper case backslash key) inside a string:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<TELL "You are knocked unconscious." CR
\end_layout

\begin_layout Plain Layout

"Later, you come to.">
\end_layout

\begin_layout Plain Layout

<TELL "You are knocked unconscious.|
\end_layout

\begin_layout Plain Layout

Later, you come to.">
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would both print out as:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

You are knocked unconscious.
\end_layout

\begin_layout Plain Layout

Later, you come to.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The CR or vertical bar prevents "Later..." from appearing on the same line,
 immediately after "...unconscious." If you wanted a blank line between the
 two lines, you'd simply use two CRs (or two vertical bars).
\end_layout

\begin_layout Standard
Note: When a TELL displays a bunch of text which is longer than the width
 of the player's screen you do not have to worry about putting in a carriage
 return when the text reaches the right hand margin.
 The game will do this automically for you.
 When you are typing a string in a TELL, you can hit the RETURN/ENTER key
 on your keyboard as much as you want; it won't affect where CRs occur when
 the game is played.
 Example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<TELL "You walk down the hall
\end_layout

\begin_layout Plain Layout

for a long time.
 Suddenly,
\end_layout

\begin_layout Plain Layout

a trap door opens
\end_layout

\begin_layout Plain Layout

under you!" CR "You fall into darkness." CR>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would appear on the screen like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

You walk down the hall for a long time.
 Suddenly, a
\end_layout

\begin_layout Plain Layout

trap door opens under you!
\end_layout

\begin_layout Plain Layout

You fall into darkness.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A TELL should end in a carriage return if it concludes the handling of the
 input, as most TELLs do.
 This ensures the blank line before the next input prompt.
 The game will automatically put in a CR before the prompt (unless the player
 is in superbrief mode), and you'll end up with the proper-looking format:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>WALK AROUND THE TREE
\end_layout

\begin_layout Plain Layout

You circle the trunk.
 Fun, huh?
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you leave the CR off the end of this TELL, you'd get:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>WALK AROUND THE TREE
\end_layout

\begin_layout Plain Layout

You circle the trunk.
 Fun, huh?
\end_layout

\begin_layout Plain Layout

>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even worse, if you leave the CR off, and the player is in superbrief mode:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>WALK AROUND THE TREE
\end_layout

\begin_layout Plain Layout

You circle the trunk.
 Fun, huh?>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note how the prompt appears on the same line as the text output.
\end_layout

\begin_layout Section
Vehicles
\end_layout

\begin_layout Standard
Most of the time, the LOC of the player is a room.
 However, there are cases where the PLAYER object is moved into another
 object; this type of object is called a vehicle.
\end_layout

\begin_layout Standard
The term vehicle is somewhat of a misnomer.
 The earliest examples of vehicles, such as the raft in Zork I or the balloon
 in Zork II, did move the player around from room to room.
 However, a vehicle has come to mean any non-room object which the player
 can enter, which includes such stationary things as a chair or bed.
\end_layout

\begin_layout Standard
To create a vehicle, give the object in question the VEHBIT flag.
 In addition, vehicles should all have the CONTBIT, OPENBIT, and SEARCHBIT
 as well.
 When a player is in a vehicle, it will be mentioned in the room description
 thusly:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

Living Room, on the couch
\end_layout

\begin_layout Plain Layout

     You are in a starkly-modern living room with...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

Bulb-Changing Room, on the stepladder
\end_layout

\begin_layout Plain Layout

     This is a room whose ceiling is covered with sockets...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The purpose of vehicles are several-fold.
 The first is that they allow a player to be in both an object and a room
 at the same time.
 For example, if you sit on the bar stool, the STOOL object becomes the
 LOC of the PLAYER object.
 However, the stool is in the PUB room, so the player is (indirectly) still
 in the PUB room, and can see it as well as anything else in it.
\end_layout

\begin_layout Standard
Another purpose is that it gives the vehicle an opportunity to handle the
 input, via M-BEG, as you'll read about in the section called The Bigger
 Picture.
 
\end_layout

\begin_layout Standard
Finally, some vehicles do actually move the player around from room to room,
 often in interesting ways.
\end_layout

\begin_layout Chapter
The Bigger Picture
\end_layout

\begin_layout Section
The Main Loop
\end_layout

\begin_layout Standard
When a player boots the game, the first thing the interpreter does (as far
 as you're concerned) is to call a routine called GO.
 This routine should include things like the opening text, the title screen
 graphic, a call to V-VERSION (to print all the copyright and release number
 info), and a call to V-LOOK (to describe the opening location).
 It should also queue any interrupts whose runtime is based on the start
 of the game, such as the interrupt that causes the earthquake in 
\noun on
Zork III
\noun default
, or the interrupt that causes the Feinstein to blow up in 
\noun on
Planetfall
\noun default
.
\end_layout

\begin_layout Standard
The last thing that GO should do is call the routine called MAIN-LOOP.
 MAIN-LOOP is sort of the king of ZIL routines; other than GO, every routine
 in the game is called by MAIN-LOOP, or by a routine that is called by MAIN-LOOP
, or by a routine that is called by a routine that is called by MAIN-LOOP,
 etc.
\end_layout

\begin_layout Standard
MAIN-LOOP is basically a giant REPEAT which loops once for each turn of
 the game.
 Simplified, it works something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE MAIN-LOOP (argument-list-from-hell)
\end_layout

\begin_layout Plain Layout

    <REPEAT ()
\end_layout

\begin_layout Plain Layout

        <PARSER>
\end_layout

\begin_layout Plain Layout

        <COND (<did-the-parser-fail?>
\end_layout

\begin_layout Plain Layout

               <AGAIN>)>
\end_layout

\begin_layout Plain Layout

        <PERFORM ,PRSA ,PRSO ,PRSI>
\end_layout

\begin_layout Plain Layout

        <COND (<did-this-input-cause-time-to-pass?>
\end_layout

\begin_layout Plain Layout

               <call-room-function-with-M-END>
\end_layout

\begin_layout Plain Layout

               <CLOCKER>)>>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
First, the parser is called.
 If the parser fails, it prints some failure message, and the turn is considered
 complete.
 AGAIN sends you to the top of the REPEAT, and the new turn begins.
 If the parser succeeds, it identifies the PRSA, PRSO, and PRSI.
 PERFORM is called, and uses that information to offer the PRSI's and PRSO's
 action routine a chance to handle the input.
 If not, it lets the verb default handle the input.
 Finally, unless the input was a non-time-running one, such as SUPERBRIEF
 or UNSCRIPT, the MAIN-LOOP causes events to occur via M-END and CLOCKER.
\end_layout

\begin_layout Standard
The MAIN-LOOP runs over and over until something, such as JIGS-UP or V-QUIT,
 tells the interpreter to end the game.
 This is done using the <QUIT> instruction.
\end_layout

\begin_layout Standard
The MAIN-LOOP does lots of other stuff as well.
 For example, if the player used a pronoun, such as IT in his/her input,
 in place of an object, the MAIN-LOOP decides what the word refers to, and
 substitutes the object.
 Therefore, it would convert an input like GIVE IT TO RIFLEMAN to GIVE BULLET
 TO RIFLEMAN.
\end_layout

\begin_layout Section
More About PERFORM
\end_layout

\begin_layout Standard
Up to now, you've been told that PERFORM gives three routines the opportunity
 to handle the input: the PRSI's action routine, the PRSO's action routine,
 and the verb default routine.
 It can now be revealed, for the first time ever on nationwide TV, that
 this was a gross simplification; there are actually many more places where
 the input can be handled.
\end_layout

\begin_layout Standard
Before anything else, PERFORM gives the WINNER action routine an opportunity.
 WINNER is a global variable which is usually set to the PLAYER object.
 This is the object that represents the player and gets moved around from
 location to location as the player moves, and which contains all of the
 player's inventory.
 Note that this is not the same as the ME object, which is used when you
 use ME in an input, as in KILL ME.
\end_layout

\begin_layout Standard
If you give the PLAYER object an action routine, such as PLAYER-F, then
 PLAYER-F will get the first opportunity to handle the input.
 An example of how this is used is when the player is a ghost in 
\noun on
Zork I
\noun default
.
 This allows all the things which are handled differently when the player
 is a ghost to be handled in one spot.
 (See DEAD-FUNCTION in the 
\noun on
Zork I
\noun default
 ZIL files.)
\end_layout

\begin_layout Standard
Sometimes, the PLAYER object is not the WINNER.
 This is most often the case when you are talking to a character in the
 game; for that turn, that character is the WINNER, and the character's
 action routine gets the opportunity to handle the input.
 You'll hear more about this in the section on Actors.
\end_layout

\begin_layout Standard
Next, PERFORM gives the room's action routine an opportunity by calling
 it with an argument called M-BEG.
 (Actually, if the player's LOC is not a room, PERFORM first calls the vehicle's
 action routine.) Here's an example of an room action routine with an M-BEG
 clause:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE TORTURE-CHAMBER-F (RARG)
\end_layout

\begin_layout Plain Layout

    <COND (<AND <EQUAL? .RARG ,M-BEG>
\end_layout

\begin_layout Plain Layout

                ,PLAYER-STRAPPED
\end_layout

\begin_layout Plain Layout

                <VERB? TAKE WALK LEAP ATTACK>>
\end_layout

\begin_layout Plain Layout

           <TELL
\end_layout

\begin_layout Plain Layout

"You're strapped to the wall and can't move!" CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After the M-BEG, PERFORM sees if there is a pre-action, and if so, gives
 that routine an opportunity to handle the input.
 A pre-action is a routine associated with a particular verb, and which
 gets this early handling opportunity, to compensate for the fact that the
 verb default gets such a late opportunity.
 You'll find out in the section on the Syntax File how you define a pre-action.
 By convention the pre-action for a verb called V-FOO is called PRE-FOO.
\end_layout

\begin_layout Standard
Here's a common example of how a pre-action is useful.
 Let's say you have a verb SHOOT.
 Obviously, if the player doesn't have the GUN object, he can't shoot anyone
 or anything.
 You'd want the handler for such an input to say, "You don't have a gun!"
 or some such.
 If you wait until the V-SHOOT verb default to handle it, then an action
 routine may incorrectly handle the input before then.
 For example, TIN-CAN-F might simply check <VERB? SHOOT> and print "You
 hit a bull's-eye, knocking the can off the fence." On the other hand, you
 don't want to have every action routine that handles SHOOT have to check
 whether the player has a gun; that's very inefficient.
 The answer is to have a pre-action, called PRE-SHOOT, which looks like
 this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE PRE-SHOOT ()
\end_layout

\begin_layout Plain Layout

    <COND (<IN? ,GUN ,PLAYER>
\end_layout

\begin_layout Plain Layout

           <RFALSE>)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <TELL "You don't have a gun!" CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, the PRSI's action routine is given the opportunity, etc.
 There's one last complication: something called a CONTFCN.
 If the LOC of the PRSI has a property called CONTFCN, than the routine
 named in the CONTFCN property is first given the opportunity to handle.
 The same thing happens before the PRSO's action routine.
 I've never used a CONTFCN myself, so don't worry if you don't understand
 the concept.
\end_layout

\begin_layout Standard

\emph on
[Stu
\emph default
 — 
\emph on
please write something about BE-verbs here.]
\end_layout

\begin_layout Section
Calling PERFORM Directly
\end_layout

\begin_layout Standard
As you've already learned, PERFORM is called by the MAIN-LOOP for the purposes
 of handling the input.
 It is called using the PRSA, PRSO, and PRSI identified by the parser.
 However, it is very common and very useful to call PERFORM yourself, with
 a different PRSA or PRSO or PRSI.
 The most common reason for calling PERFORM yourself is to avoid duplicating
 code.
\end_layout

\begin_layout Standard
PERFORM is called with one required argument, the PRSA, and two optional
 arguments, the PRSO and the PRSI.
 One complication: when you use PERFORM, you must refer to the PRSA by its
 internal name, which is in the form ,V?VERB.
 Example: whereas you might say <VERB?
\begin_inset space ~
\end_inset

SMELL>, you would say <PERFORM ,V?SMELL>.
\end_layout

\begin_layout Standard
Here's what a few potential calls to PERFORM might look like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PERFORM ,V?LEAP>
\end_layout

\begin_layout Plain Layout

<PERFORM ,V?EAT ,PIZZA>
\end_layout

\begin_layout Plain Layout

<PERFORM ,V?TAKE-FROM ,CANDY ,BABY>
\end_layout

\begin_layout Plain Layout

<PERFORM ,PRSA ,ELVISH-SWORD>
\end_layout

\begin_layout Plain Layout

<PERFORM ,V?GIVE ,PRSI ,PRSO>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the first example, PRSO and PRSI will both be false in the new PERFORM.
 In the second example, PRSI will be false.
 Notice the use of PRSA in the fourth example; in this case, you are leaving
 PRSA the same, and are presumably just changing the PRSO.
 In the last example, notice that PRSI comes before PRSO; in this case,
 the PRSI will become the PRSO and vice versa.
 (This is a very common case, which you'll hear more about in the chapter
 on syntaxes.) Here's an example of a case where you would call PERFORM.
 Let's say you had a verb default that looked like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE V-SHOOT ()
\end_layout

\begin_layout Plain Layout

    <COND (<FSET? ,PRSO ,ACTORBIT>
\end_layout

\begin_layout Plain Layout

           <TELL "An expert shot fells" T ,PRSO>
\end_layout

\begin_layout Plain Layout

           <JIGS-UP ".
 The police arrive, and after a
\end_layout

\begin_layout Plain Layout

long and lurid trial, you get the chair.">)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <TELL "The shot ricochets off" T ,PRSO ",
\end_layout

\begin_layout Plain Layout

almost hitting you." CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then you might have an action routine for the PISTOL object which looked
 like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE PISTOL-F ()
\end_layout

\begin_layout Plain Layout

    <COND (<AND <VERB? FIRE>
\end_layout

\begin_layout Plain Layout

                <PRSO? ,PISTOL>>
\end_layout

\begin_layout Plain Layout

           <PERFORM ,V?SHOOT ,PRSI>
\end_layout

\begin_layout Plain Layout

           <RTRUE>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The effect of this PERFORM would be to take an input like FIRE THE PISTOL
 AT UNCLE OTTO and have it executed as though the player had actually typed
 SHOOT UNCLE OTTO.
 This obviates the need to handle the shooting in PISTOL-F; instead, V-SHOOT,
 which is already set up to handle a shooting, gets to handle it.
\end_layout

\begin_layout Standard
Note the RTRUE after the PERFORM.
 In virtually all cases, a PERFORM must have an RTRUE after it.
 Reason: PERFORM itself usually returns false.
 If the PERFORM were the last thing in the action routine, which it usually
 is, then the action routine would in turn RFALSE to the original PERFORM
 — which is still going on! The original PERFORM would then think that the
 action routine hadn't handled the input, when in fact it had.
 If the RTRUE were missing from PISTOL-F, something like this would happen:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>FIRE THE GUN AT THE FIRE HYDRANT
\end_layout

\begin_layout Plain Layout

The shot ricochets off the fire hydrant, almost hitting
\end_layout

\begin_layout Plain Layout

you.
\end_layout

\begin_layout Plain Layout

You can't fire the gun -- it's not gainfully employed!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Flushing inputs
\end_layout

\begin_layout Standard
The player is permitted to type multiple commands on the same input line:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>NORTH.
 NORTH.
 OPEN TRAP DOOR.
 DOWN.
 TAKE EGG
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, sometimes something will happen in the middle of executing this
 string of inputs that will possibly make the player want to rethink the
 subsequent moves: something like a character appearing or attacking, the
 player tripping and dropping something or everything, and so on.
 Example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>NORTH.
 OPEN TRAP DOOR.
 DOWN.
 EAST
\end_layout

\begin_layout Plain Layout

Dungeon
\end_layout

\begin_layout Plain Layout

Your torch slips out of your hands as you open the
\end_layout

\begin_layout Plain Layout

heavy trap door.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

It is pitch black.
 You are likely to be eaten by a
\end_layout

\begin_layout Plain Layout

grue.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Oh no! You have wandered into the slavering fangs...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Clearly, it is only fair to flush the inputs after the OPEN TRAP DOOR, and
 give the player a chance to reconsider his or her descent into darkness.
 
\end_layout

\begin_layout Standard
Until recently, this was done by putting RFATAL (for return fatal) in the
 object's action routine:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE TRAP-DOOR-F ()
\end_layout

\begin_layout Plain Layout

    <COND (<AND <VERB? OPEN>
\end_layout

\begin_layout Plain Layout

                <NOT <FSET? ,TRAP-DOOR ,OPENBIT>>>
\end_layout

\begin_layout Plain Layout

           <FSET ,TRAP-DOOR ,OPENBIT>
\end_layout

\begin_layout Plain Layout

           <COND (<IN? ,TORCH ,PLAYER>
\end_layout

\begin_layout Plain Layout

                  <MOVE ,TORCH ,HERE>
\end_layout

\begin_layout Plain Layout

                  <TELL "Your torch slips out of your hands
\end_layout

\begin_layout Plain Layout

as you open the heavy trap door." CR>
\end_layout

\begin_layout Plain Layout

                  <RFATAL> ;"flush any additional inputs")
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <TELL "Oomph! You open the trap door.
 It
\end_layout

\begin_layout Plain Layout

sure is heavy!" CR>)>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The RFATAL returns a value called M-FATAL to PERFORM, which in turn returns
 M-FATAL to the MAIN-LOOP.
 The MAIN-LOOP then knows to ignore any subsequent commands that were on
 the input line.
\end_layout

\begin_layout Standard
The problem with this scheme was that if the action routine called another
 routine, which then called another routine, and so on, then each of these
 deeper and deeper routine calls would all have to carefully pass the M-FATAL
 upwards to PERFORM.
 Thus, lots of extra code and lots of chances to screw up.
\end_layout

\begin_layout Standard
Therefore, a new and simpler method has been developed.
 They use a global variable called P-CONT, which the parser used to keep
 track of whether there are additional inputs on the input line.
 If you want to flush any subsequent inputs, just <SETG P-CONT -1>.
 This can be done at any level; it doesn't have to be passed up to MAIN-LOOP
 like a bucket brigade.
 When the cycle gets back to MAIN-LOOP, MAIN-LOOP will check the value of
 P-CONT; if the value is -1, MAIN-LOOP will flush any additional inputs,
 and go straight back to the ">" prompt.
\end_layout

\begin_layout Standard
Under this new and improved theory, TRAP-DOOR-F would look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE TRAP-DOOR-F ()
\end_layout

\begin_layout Plain Layout

    <COND (<AND <VERB? OPEN>
\end_layout

\begin_layout Plain Layout

                <NOT <FSET? ,TRAP-DOOR ,OPENBIT>>>
\end_layout

\begin_layout Plain Layout

           <FSET ,TRAP-DOOR ,OPENBIT>
\end_layout

\begin_layout Plain Layout

           <COND (<IN? ,TORCH ,PLAYER>
\end_layout

\begin_layout Plain Layout

                  <MOVE ,TORCH ,HERE>
\end_layout

\begin_layout Plain Layout

                  <SETG P-CONT -1> ;"flush inputs"
\end_layout

\begin_layout Plain Layout

                  <TELL "Your torch slips out of your
\end_layout

\begin_layout Plain Layout

hands as you open the heavy trap door." CR>)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <TELL "Oomph! You open the trap door.
 It
\end_layout

\begin_layout Plain Layout

sure is heavy!" CR>)>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Section*
EXERCISE TWO
\end_layout

\begin_layout Standard
Using what you've learned so far, design and implement a mini-game, with
 a small geography of about five interconnected rooms, and about five objects
 scattered about those rooms.
 Write action routines for all of the objects, and as many of the rooms
 as are applicable.
 Include at least one event.
 When you're done, get someone to look over your code, and to help you compile
 it.
 Then spend some time playing with what you've created.
 Congratulations! You've taken a big step on the road to Imphood!
\end_layout

\begin_layout Chapter
The Syntax File
\end_layout

\begin_layout Section
Basic Syntaxes
\end_layout

\begin_layout Standard
Syntaxes are the writer's way of telling the parser what the legal sentence
 structures are, and what PRSA a given sentence structure produces.
 Sentence structures are composed of verbs, noun phrases, and prepositions.
 Every syntax is associated with an internal-verb, which is what you check
 for in the predicate VERB? and which will ultimately lead to an associated
 verb default in the VERBS file if not handled earlier.
\end_layout

\begin_layout Standard
Syntaxes are defined in a file called, appropriately, the syntax file.
 Each syntax is a line in that file that looks something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX EAT OBJECT = V-EAT>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case, EAT is a verb, OBJECT is the point where a noun phrase occurs,
 and EAT is the resulting PRSA or action.
 So, if the player typed in any of the following
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>EAT BIRD
\end_layout

\begin_layout Plain Layout

>EAT THE PHEASANT
\end_layout

\begin_layout Plain Layout

>EAT THE LIGHTLY SEASONED PHEASANT-UNDER-GLASS
\end_layout

\begin_layout Plain Layout

>EAT THE BIRD IN MY HAND
\end_layout

\end_inset


\end_layout

\begin_layout Standard
the parser would match the input up with that syntax, and return EAT as
 the PRSA, the PHEASANT object as the PRSO, and <> as the PRSI.
 
\end_layout

\begin_layout Standard
Note that the verb does not have to be the same as the resulting PRSA.
 For example, you could have a syntax like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX SLICE OBJECT = V-CUT>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The verb is slice, but the PRSA is CUT.
 The distinction is that "SLICE" is the word from the player's input, but
 CUT is the internal name for the verb when the input matches this syntax.
 A few of the most common examples of this:
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\bar under
Input word(s)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\bar under
Internal name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ATTACK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-KILL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
BREAK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-MUNG
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
BLOW OUT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-EXTINGUISH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ENTER
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-BOARD
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
GET
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-TAKE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
GET IN
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-ENTER
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
GET OUT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-EXIT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
JUMP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-LEAP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LEAVE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-DROP or V-EXIT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
LOOK AT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-EXAMINE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
PICK UP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-TAKE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
WALK UP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
V-CLIMB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Prepositions in Syntaxes
\end_layout

\begin_layout Standard
Prepositions appear in a syntax definition exactly as they would appear
 in an input:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX LOOK THROUGH OBJECT = V-LOOK-INSIDE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, if the player types
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>LOOK THROUGH THE TELESCOPE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
the game will set PRSA to LOOK-INSIDE.
 Now we can see the importance of the syntax definition; if the game had
 syntaxes like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX LOOK UNDER OBJECT = V-LOOK-UNDER>
\end_layout

\begin_layout Plain Layout

<SYNTAX WALK THROUGH OBJECT = V-WALK-THROUGH>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
but not
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX LOOK THROUGH OBJECT = V-LOOK-INSIDE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and the player typed
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>LOOK THROUGH THE TELESCOPE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
the game would know all the words in the input, but it would not be able
 to match the sentence structure with any known syntax.
 The parser would fail, producing a message like "Sorry, but I don't undertand
 that sentence."
\end_layout

\begin_layout Section
Syntaxes with Indirect Objects
\end_layout

\begin_layout Standard
All the syntax definitions you've looked at so far are for inputs with a
 PRSO but no PRSI.
 To do so, simply have two OBJECT spots in the syntax definition:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX GIVE OBJECT TO OBJECT = V-GIVE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, the input
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>GIVE THE MAP OF ELBA ISLAND TO UNCLE OTTO
\end_layout

\end_inset


\end_layout

\begin_layout Standard
would get parsed as PRSA equals GIVE, PRSO equals ELBA-MAP object, and PRSI
 equals UNCLE-OTTO.
\end_layout

\begin_layout Standard
Furthermore, you can have a syntax definition with no OBJECT spot, just
 a verb:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX INVENTORY = V-INVENTORY>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that you can have many syntaxes which use the same verb, and which
 can sometimes produce the same PRSA, but which can sometimes produce different
 PRSAs:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX GET OBJECT = V-TAKE>
\end_layout

\begin_layout Plain Layout

<SYNTAX GET IN OBJECT = V-ENTER>
\end_layout

\begin_layout Plain Layout

<SYNTAX GET ON OBJECT = V-ENTER>
\end_layout

\begin_layout Plain Layout

<SYNTAX GET OFF OBJECT = V-EXIT>
\end_layout

\begin_layout Plain Layout

<SYNTAX GET OBJECT WITH OBJECT = V-TAKE-WITH>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Generally, when you have such a "family" of syntax definitions, you put
 them in order from the simplest to the most complicated.
\end_layout

\begin_layout Section
Pre-actions
\end_layout

\begin_layout Standard
If you recall from the section 8.2, a pre-action is a routine associated
 with a verb, and which is given a pretty early opportunity to handle the
 input.
 The way to define that a verb has a pre-action is in the syntax file, thusly:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX SHOOT OBJECT = V-SHOOT PRE-SHOOT>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the verbs file, there must be two routines for this verb, the verb default
 routine (called V-SHOOT) and the pre-action routine (called PRE-SHOOT).
 Remember that a PRSA can appear in more than one syntax.
 If it has a pre-action in one of those syntaxes, it must have that same
 pre-action in all of those syntaxes.
 For example, this would be illegal:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX SHOOT OBJECT = V-SHOOT PRE-SHOOT>
\end_layout

\begin_layout Plain Layout

<SYNTAX FIRE AT OBJECT = V-SHOOT>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
because the first V-SHOOT syntax has a pre-action and the second one doesn't.
 Likewise, this would be illegal:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX SHOOT OBJECT = V-SHOOT PRE-SHOOT>
\end_layout

\begin_layout Plain Layout

<SYNTAX FIRE AT OBJECT = V-SHOOT PRE-FIRE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
because you have two different pre-actions defined for the same PRSA.
\end_layout

\begin_layout Section
The FIND Feature
\end_layout

\begin_layout Standard
You are, of course, familiar with this parser occurence (if you're not,
 go back to Testing and Lose One Turn):
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>TAKE
\end_layout

\begin_layout Plain Layout

[the jeweled eggplant]
\end_layout

\begin_layout Plain Layout

Taken.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>ATTACK MIKE DORNBROOK
\end_layout

\begin_layout Plain Layout

[with the marketing budget]
\end_layout

\begin_layout Plain Layout

You thrust the marketing budget at Mikey, who turns
\end_layout

\begin_layout Plain Layout

pale and dashes away, leaving a Mikey-sized hole in the
\end_layout

\begin_layout Plain Layout

conference room wall.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since you're already beginning to think like an Implementor, you're asking
 yourself "Gee! I wonder how the parser knew to pick the eggplant in the
 first case and the budget in the second case?" The answer is FIND in the
 syntax definition.
 Here's what these two syntaxes might look like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX TAKE OBJECT (FIND TAKEBIT) = V-TAKE>
\end_layout

\begin_layout Plain Layout

<SYNTAX ATTACK OBJECT WITH OBJECT (FIND WEAPONBIT)
\end_layout

\begin_layout Plain Layout

    = V-ATTACK>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you put FIND in a syntax definition, along with the name of the flag,
 and the player uses that syntax, but gives incomplete information, the
 parser will look to see if there is one (and only one) object present which
 has that flag; if so, it assumes that object! (This is sometimes referred
 to as GWIM, for "get what I mean.")
\end_layout

\begin_layout Standard
If the parser finds zero, or more than one, object present with that flag,
 it will ask "What do you want to take?" or "What do you want to attack
 Mike Dornbrook with?" (This feature, where the parser is asking for a little
 more information to complete an input, is called orphaning.)
\end_layout

\begin_layout Standard
There is one unusual use of the FIND feature.
 Normally, the parser cannot handle a syntax which is just a verb and a
 preposition, such as LOOK UP or FUCK OFF.
 However, a kludge has been installed using a flag called the ROOMSBIT:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX LOOK UP OBJECT (FIND ROOMSBIT) = V-LOOK-UP>
\end_layout

\begin_layout Plain Layout

<SYNTAX FUCK OFF OBJECT (FIND ROOMSBIT) = V-FUCK-OFF>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Thanks to this kludge, when the parser gets to this syntax, it will not
 complain about the lack of an object.
 Instead, it will set PRSO to the ROOMS object (that special object which
 is the LOC of all rooms).
 You can then have V-LOOK-UP or V-FUCK-OFF check whether PRSO is ROOMS.
 Since there is no way the player can ever refer to the ROOMS object, if
 ROOMS is the PRSO you can be sure that the player typed LOOK UP without
 an object.
 Here's what such a V-LOOK-UP might look like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE V-LOOK-UP ()
\end_layout

\begin_layout Plain Layout

    <COND (<PRSO? ,ROOMS>
\end_layout

\begin_layout Plain Layout

           <TELL "You stare up at the sky until you
\end_layout

\begin_layout Plain Layout

get a stiff neck." CR>)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <TELL "You can look up a chimney; you can
\end_layout

\begin_layout Plain Layout

look up a dress; you can look up your uncle in the
\end_layout

\begin_layout Plain Layout

phone book; but you can't look up" A ,PRSO "!" CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Section
Syntax Tokens
\end_layout

\begin_layout Standard
There are several tokens which can appear in parentheses within a syntax
 definition: HAVE, TAKE, MANY, EVERYWHERE, ADJACENT, HELD, CARRIED, ON-GROUND,
 and IN-ROOM.
 This parenthetical list appears after either or both OBJECTs:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX GIVE OBJECT (HAVE)
\end_layout

\begin_layout Plain Layout

    TO OBJECT (ON-GROUND IN-ROOM) = V-GIVE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
HAVE informs the parser that the object in question must be in the player's
 inventory before the input can be successfully parsed.
 If the player uses a syntax with a HAVE, and the object in question is
 not in the player's inventory, the parser will fail with a message like,
 "You aren't holding the object." For instance, given the GIVE syntax defined
 above, if the player wasn't holding the pineapple, and said GIVE THE PINEAPPLE
 TO THE HULA DANCER, the response would be "You aren't holding the pineapple."
 Note that HAVE is after the first OBJECT; the player doesn't have to have
 the hula dancer in his or her inventory!
\end_layout

\begin_layout Standard
TAKE tells the parser that if the object referred to is not in the player's
 inventory, but it is takeable, to take it (by moving it to the player's
 inventory) before returning to let the game handle the input.
 When the parser does this, it will TELL something like, "[taking the FOO
 first]".
 This is referred to as an implicit take, because the player is getting
 the object without having asked for it.
 A verb which commonly does an implicit take is READ.
\end_layout

\begin_layout Standard
MANY tells the parser that it is okay to allow multiple direct objects with
 this verb (or multiple indirect objects, if the MANY is placed after the
 second OBJECT in the syntax).
 Normally, if the player said EXAMINE SALT AND PEPPER, the parser would
 fail, saying "[You can't use multiple direct objects with 'examine.']" However,
 if the syntax definition was:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX EXAMINE OBJECT (MANY) = V-EXAMINE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then the parser would allow it.
 All the items listed in the input will then be examine, preceded by their
 DESC and a colon, thusly:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>EXAMINE SALT AND PEPPER
\end_layout

\begin_layout Plain Layout

salt: It is white and crystalline.
\end_layout

\begin_layout Plain Layout

pepper: It is powdery, in various shades of brown.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
EVERYWHERE tells the parser that the object referred to doesn't have to
 be visible.
 In these cases, you are telling the parser to look everywhere in the game
 to match the player's input.
 For example, you can ASK GEORGE BAILEY ABOUT MR.
 POTTER even when the MR-POTTER object isn't present; you can FOLLOW SANTA
 CLAUS after he leaves the room and is no longer referenceable.
 Therefore these syntaxes would look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX FOLLOW OBJECT (EVERYWHERE) = V-FOLLOW>
\end_layout

\begin_layout Plain Layout

<SYNTAX ASK OBJECT ABOUT OBJECT (EVERYWHERE)
\end_layout

\begin_layout Plain Layout

    = V-ASK-ABOUT>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I guess there's another token called ADJACENT, but I have no idea what it
 does.
 
\end_layout

\begin_layout Standard

\emph on
[Stu?] 
\end_layout

\begin_layout Standard

\emph on
[The other four tokens
\emph default
 — 
\emph on
ON-GROUND, IN-ROOM, HELD, and CARRIED
\emph default
 — 
\emph on
are incredibly confusing, and no one really understands them except Stu,
 so he should probably write this bit.]
\end_layout

\begin_layout Section
Verb Synonyms
\end_layout

\begin_layout Standard
In much the same way that objects can have synonyms for the nouns and adjectives
 that are used to refer to them, using the SYNONYM and ADJECTIVE properties,
 a verb can also have synonyms.
 
\end_layout

\begin_layout Standard
In the syntax file, you would put something like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<VERB-SYNONYM WORRY FRET AGONIZE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nearby, you would probably have a syntax definition like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX WORRY ABOUT OBJECT = V-WORRY>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With the VERB-SYNONYM list, the player could then type WORRY ABOUT UNCLE
 OTTO, or FRET ABOUT UNCLE OTTO, or AGONIZE ABOUT UNCLE OTTO, and all would
 mean the same thing.
 Note that you could accomplish the same result by having three syntax definitio
ns:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX WORRY ABOUT OBJECT = V-WORRY>
\end_layout

\begin_layout Plain Layout

<SYNTAX FRET ABOUT OBJECT = V-WORRY>
\end_layout

\begin_layout Plain Layout

<SYNTAX AGONIZE ABOUT OBJECT = V-WORRY>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, using the VERB-SYNONYM is more efficient, especially if there are
 more than one WORRY syntax (WORRY ABOUT OBJECT, WORRY WITH OBJECT, etc.)
\end_layout

\begin_layout Standard
Actually, this synonym list can be generalized to all parts of speech, although
 it is most commonly done with verbs.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PREP-SYNONYM UNDER UNDERNEATH BENEATH BELOW>
\end_layout

\begin_layout Plain Layout

<ADJ-SYNONYM LARGE BIG GREAT HUGE>
\end_layout

\end_inset


\end_layout

\begin_layout Section
"Switch" Syntaxes
\end_layout

\begin_layout Standard
Frequently, the same action can be worded in two different ways such that
 the PRSO and PRSI are in the oppposite order in the two constructions.
 The commonest example: GIVE THE RAZOR BLADE TO THE DUCK and GIVE THE DUCK
 THE RAZOR BLADE have the same meaning.
 However, in the first example, the PRSO is the RAZOR-BLADE object and the
 PRSI is the DUCK object; in the second, PRSO is the duck and PRSI is the
 razor blade.
\end_layout

\begin_layout Standard
This is handled by creating a special second verb for the second syntax.
 This special verb usually does nothing except switch the order of the PRSO
 and the PRSI.
 The naming convention for this "switching" verb is the regular verb with
 an "S" tacked on the front.
 Thus:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SYNTAX GIVE OBJECT TO OBJECT = V-GIVE>
\end_layout

\begin_layout Plain Layout

<SYNTAX GIVE OBJECT OBJECT = V-SGIVE>
\end_layout

\begin_layout Plain Layout

<ROUTINE V-SGIVE ()
\end_layout

\begin_layout Plain Layout

    <PERFORM ,V?GIVE ,PRSI ,PRSO>
\end_layout

\begin_layout Plain Layout

    <RTRUE>>
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Actors
\end_layout

\begin_layout Section
Definition of an Actor
\end_layout

\begin_layout Standard
An actor is simply a character in an interactive fiction story.
 The term does not include the main character — the player, that is.
 Some examples of actors are the thief in 
\noun on
Zork I
\noun default
, Mr.
 Baxter in 
\noun on
Deadline
\noun default
, Floyd in 
\noun on
Planetfall
\noun default
, or Ford Prefect in 
\noun on
Hitchhiker's Guide
\noun default
.
\end_layout

\begin_layout Standard
Creating an actor is very similar to creating any other object.
 They should have a flag called the PERSONBIT.
 Also, since actors frequently have items in their possession, they should
 have the OPENBIT, CONTBIT, and SEARCHBIT so that those possessions will
 be visible to the player.
\end_layout

\begin_layout Section
Talking to an Actor
\end_layout

\begin_layout Standard
A player talks to an actor by typing something like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>SERGEANT DUFFY, PUT THE HANDCUFFS ON MOE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The parser turns an input like this into two inputs; the first one is PRSA
 equal to the verb TELL and PRSO equal to the DUFFY object; the second one
 is more conventional, with PRSA equal to PUT-ON, PRSO equal to the HANDCUFFS
 object, and PRSI equal to MOE.
\end_layout

\begin_layout Standard
Eventually, the first PERFORM will probably get to the V-TELL verb default,
 because of the PRSA in the first input.
 V-TELL will see that the PRSO is an actor, and that therefore the player
 is attempting to talk to this actor.
 It will then do three unusual things: it will set the global variable WINNER
 to this actor, it will return without outputting anything, and it will
 tell CLOCKER not to run this turn.
 Remember, WINNER is usually set to the PROTAGONIST/PLAYER object.
 However, when you speak to an actor, that actor becomes the WINNER for
 that turn (or as many turns as you're speaking to them).
 V-TELL doesn't output anything in this case, and stops time from passing,
 in order to preserve the appearance that this input was really one input,
 rather than the two inputs that the parser converted it to.
\end_layout

\begin_layout Standard
Remember also, the first opportunity to handle any input is the WINNER's
 action routine! On the second time through, for the second input, the actor's
 action routine will get called right away—this is the time and place to
 handle speaking to the actor!
\end_layout

\begin_layout Standard
The first clause in any actor's action routine should check to see whether
 the actor is the WINNER.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<EQUAL? .ARG ,M-WINNER>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If true, you know that the player was speaking to DUFFY.
 Now, within this clause, just handle what was said to the actor:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE DUFFY-F ("OPT" ARG)
\end_layout

\begin_layout Plain Layout

    <COND (<EQUAL? .ARG ,M-WINNER>
\end_layout

\begin_layout Plain Layout

           <COND (<AND <VERB? ,PUT-ON>
\end_layout

\begin_layout Plain Layout

                       <PRSO? ,HANDCUFFS>>
\end_layout

\begin_layout Plain Layout

                  <TELL "Sgt.
 Duffy arrests " T ,PRSI "." CR>)
\end_layout

\begin_layout Plain Layout

                 (<VERB? ANALYZE>
\end_layout

\begin_layout Plain Layout

                  <REMOVE ,DUFFY>
\end_layout

\begin_layout Plain Layout

                  <QUEUE I-DUFFY-RETURNS 20>
\end_layout

\begin_layout Plain Layout

                  <TELL "Duffy exits, saying 
\backslash
"I'll have to
\end_layout

\begin_layout Plain Layout

take this to the lab.
\backslash
"" CR>)
\end_layout

\begin_layout Plain Layout

                 (T
\end_layout

\begin_layout Plain Layout

                  <TELL "
\backslash
"Sorry, detective.
 My expertise
\end_layout

\begin_layout Plain Layout

extends only to police work.
\backslash
"" CR>)>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In most games, the actor's WINNER clause must handle everything said to
 that actor, thus the "Sorry, detective..." line at the end.
 Without such a catch-all, the output would be handled as though the input
 were typed to the game, rather than said to a character.
 For example, the DUFFY-F above has special responses for only two things
 that might be said to Duffy:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>DUFFY, PUT THE HANDCUFFS ON [someone]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>DUFFY, ANALYZE [something]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Suppose that the "Sorry, detective..." clause weren't there to catch anything
 else said to Duffy; the following could happen:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>DUFFY, HIT MRS.
 ROBNER
\end_layout

\begin_layout Plain Layout

You slap Mrs.
 Robner.
 Furious, she throws you out of
\end_layout

\begin_layout Plain Layout

the house.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice how the response matches an input of HIT MRS.
 ROBNER rather than DUFFY, HIT MRS.
 ROBNER.
\end_layout

\begin_layout Section
The Transit System
\end_layout

\begin_layout Chapter
The Describers
\end_layout

\begin_layout Section
Definition
\end_layout

\begin_layout Standard
There's a small package of programs which handle the descriptions for the
 player's environment: current room and visible objects.
 These routines are called the describers.
\end_layout

\begin_layout Standard
The describers are used every time a room description is needed, either
 because the player has entered a new location or because the player has
 typed LOOK.
 The describers are also called by a number of other verbs, such as INVENTORY
 or LOOK-INSIDE.
\end_layout

\begin_layout Standard
The exact details of how the describers do their job vary from game to game.
 For instance, back in the old days, objects were always printed out in
 a "laundry list" style:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>OPEN THE BOX
\end_layout

\begin_layout Plain Layout

Opening the box reveals:
\end_layout

\begin_layout Plain Layout

    a Monopoly board
\end_layout

\begin_layout Plain Layout

    a red hotel
\end_layout

\begin_layout Plain Layout

    a green house
\end_layout

\begin_layout Plain Layout

    a dog token
\end_layout

\begin_layout Plain Layout

    a fifty-dollar bill
\end_layout

\begin_layout Plain Layout

    a Park Place deed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
More recently, many games have chosen to list objects in paragraph form:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>OPEN THE BOX
\end_layout

\begin_layout Plain Layout

Opening the box reveals a Monopoly board, a red hotel,
\end_layout

\begin_layout Plain Layout

a green house, a dog token, a fifty-dollar bill, and a
\end_layout

\begin_layout Plain Layout

Park Place deed.
\end_layout

\end_inset


\end_layout

\begin_layout Section
What goes on during a LOOK
\end_layout

\begin_layout Standard
When the player types LOOK, the game should give him a full description
 of his surroundings.
 This should also happen the first time the player enters a room in brief
 mode, or any time the player enters a room in verbose mode.
\end_layout

\begin_layout Standard
In the case of LOOK, the V-LOOK verb default handles the input by calling
 two routines, one which describes the room, and another which describes
 the objects in the room.
 These routines are called DESCRIBE-ROOM and DESCRIBE-OBJECTS (in some games,
 D-ROOM and D-OBJECTS).
 In the case of the player entering a room, these two routines are called
 by the GOTO routine which handles player movement.
\end_layout

\begin_layout Section
DESCRIBE-ROOM
\end_layout

\begin_layout Standard
There are two parts to a room description: the name of the room and the
 sentence(s) describing it.
 The room name (the room object's DESC property) gets printed every time
 the player enters a room.
 The descriptive text should get printed only if the player is in verbose
 mode, or if the player is in brief mode and is entering the room for the
 first time.
 Both parts should be given when the player types LOOK.
\end_layout

\begin_layout Standard
The first thing the DESCRIBE-ROOM does is to figure out whether the area
 is lit or dark.
 If it's dark, it TELLs a string such as "It's too dark to see." and returns
 without doing anything else.
\end_layout

\begin_layout Standard
If the player's location is lit, DESCRIBE-ROOM then TELLs the room's DESC:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

Shark Tank
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some games put the room name in bold type (see the graphics section about
 the HLIGHT command):
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard

\series bold
\begin_inset space \quad{}
\end_inset

Shark Tank
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Some games tack on an addendum to the room name if the player is in a vehicle:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

Shark Tank, in the shark cage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, DESCRIBE-ROOM decides whether the second part of the room description,
 the descriptive text, is warranted — depending on the briefness mode, whether
 the room has been visited before (is the TOUCHBIT of the room set?), and
 whether the player is doing a LOOK.
\end_layout

\begin_layout Standard
If the full description is warranted, DESCRIBE-ROOM must then figure out
 where to get this description.
 The first place it checks is to see if the room has an LDESC property.
 If it does, DESCRIBE-ROOM then TELLs this string.
\end_layout

\begin_layout Standard
If a room has a description that changes over the course of game play, such
 as a door which opens or closes or a wall which collapses into rubble,
 then it must be described by the room's action routine.
 Therefore, when DESCRIBE-ROOM finds no LDESC property, it next calls the
 room's action routine with the argument M-LOOK.
 The action routine should have an <EQUAL? .RARG ,M-LOOK> predicate, and
 within this clause it should TELL the room description.
 Except in very unusual cases, all rooms must have either an LDESC or an
 M-LOOK clause.
 DESCRIBE-ROOM has now completed its work.
\end_layout

\begin_layout Section
DESCRIBE-OBJECTS
\end_layout

\begin_layout Standard
The objects in a room should get described anytime the player does a LOOK
 and anytime the player enters a room, except in SUPERBRIEF mode.
 The exception is if DESCRIBE-ROOM has decided that it is dark, and TELLed
 an appropriate string.
 It then returns false, informing V-LOOK or GOTO not to bother calling DESCRIBE-
OBJECTS.
\end_layout

\begin_layout Standard
DESCRIBE-OBJECTS is quite a bit more complicated than DESCRIBE-ROOM, because
 of all the different ways that objects can be described: FDESC, LDESC,
 DESCFCN, or default description.
 And that's not even including containment issues.
\end_layout

\begin_layout Standard
Objects may be described several ways.
 One way is the default; don't do anything special to describe the object.
 Instead, the object's DESC is used to fill in a default description.
 For example, if you created a bicycle horn with no special description,
 and with a DESC of "bicycle horn," then the player would enter a room with
 the horn in it and see:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

Bicycle Store
\end_layout

\begin_layout Plain Layout

     This huge shop is filled with bicycles of every
\end_layout

\begin_layout Plain Layout

description.
 One wall is covered with a pegboard of
\end_layout

\begin_layout Plain Layout

parts and accessories.
\end_layout

\begin_layout Plain Layout

     You can see a bicycle horn here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's say you wanted to give the horn a more interesting description.
 You could give the horn object an LDESC property:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

(LDESC "A shiny brass horn is lying on the ground.")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The LDESC will be used by DESCRIBE-OBJECTS whenever the horn is on the ground
 in the player's room.
 In other words, instead of the above vanilla description, the player would
 see:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

Bicycle Store
\end_layout

\begin_layout Plain Layout

     This huge shop is filled with bicycles of every
\end_layout

\begin_layout Plain Layout

description.
 One wall is covered with a pegboard of
\end_layout

\begin_layout Plain Layout

parts and accessories.
\end_layout

\begin_layout Plain Layout

     A shiny brass horn is lying on the ground.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The horn's DESC would still be used for verb defaults, such as "Shaking
 the bicycle horn isn't very helpful."
\end_layout

\begin_layout Standard
Another option is to give the horn an FDESC (as in First DESCription):
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

(FDESC "One of the items on the pegboard wall is a
\end_layout

\begin_layout Plain Layout

shiny brass horn.
 It almost seems to be calling to you,
\end_layout

\begin_layout Plain Layout

begging to be mounted on a handlebar.")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The FDESC will be used by DESCRIBE-OBJECTS as long as the horn is in its
 original state.
 If the player takes the horn, its TOUCHBIT will be set, and the FDESC will
 no longer be used.
 Instead, the LDESC will be used, if the horn has one, else the DESC/default.
 (Note that an object can have both an FDESC and an LDESC.) The player would
 now see:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

Bicycle Store
\end_layout

\begin_layout Plain Layout

     This huge shop is filled with bicycles of every
\end_layout

\begin_layout Plain Layout

description.
 One wall is covered with a pegboard of
\end_layout

\begin_layout Plain Layout

parts and accessories.
\end_layout

\begin_layout Plain Layout

     One of the items on the pegboard wall is a shiny
\end_layout

\begin_layout Plain Layout

brass horn.
 It almost seems to be calling to you,
\end_layout

\begin_layout Plain Layout

begging to be mounted on a handlebar.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reason for the FDESC should be apparent.
 If the player picks up the horn, then drops it in the VEGETABLE-STAND room,
 you don't want a LOOK to give the "pegboard wall" description—the pegboard
 wall isn't even here (in VEGETABLE-STAND)!
\end_layout

\begin_layout Standard
Note that there's no reason for giving an FDESC to an untakeable object;
 its TOUCHBIT will never get set, and the FDESC will be used throughout
 the play of the game.
 Instead, use an LDESC to give an untakeable object a non-vanilla description.
\end_layout

\begin_layout Standard
The last describer option is the DESCFCN.
 It will be described in detail in the next section.
\end_layout

\begin_layout Standard
DESCRIBE-OBJECTS makes three passes through all the objects in a room, in
 order to describe them in a certain order.
 First, objects with DESCFCNs and FDESCs are described.
 Then, any object with an LDESC is described.
 Finally, all the remaining objects are described using their DESCs:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

Amazing Describer Room
\end_layout

\begin_layout Plain Layout

     This is a dimly-lit room filled with arcane
\end_layout

\begin_layout Plain Layout

objects and complex routines.
\end_layout

\begin_layout Plain Layout

     Sitting on a shelf is an object with an FDESC.
 It
\end_layout

\begin_layout Plain Layout

hasn't been touched yet.
\end_layout

\begin_layout Plain Layout

     An object with an LDESC is lying in a discarded
\end_layout

\begin_layout Plain Layout

heap on the ground.
\end_layout

\begin_layout Plain Layout

     You can see a drab object, a boring object, and a
\end_layout

\begin_layout Plain Layout

dismally uninteresting object here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The contents of objects are described immediately after the object itself:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

Amazing Describer Room
\end_layout

\begin_layout Plain Layout

     A box with an LDESC has been discarded here.
 It
\end_layout

\begin_layout Plain Layout

seems that the box contains a foo and a bar.
\end_layout

\begin_layout Plain Layout

     You can see a drab object, a boring object, and a
\end_layout

\begin_layout Plain Layout

dismally uninteresting object here.
 It seems that the
\end_layout

\begin_layout Plain Layout

boring object contains a bletch.
\end_layout

\end_inset


\end_layout

\begin_layout Section
DESCFCNs
\end_layout

\begin_layout Standard
A DESCFCN is the most complex, but most powerful, way to describe an object.
 Basically, it means creating a function whose purpose is to describe the
 object in any given situation.
\end_layout

\begin_layout Standard
The first step is to give the object the DESCFCN property, indicating the
 name of the routine which will handing the describing:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

(DESCFCN HORN-DESC-F)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, write the routine:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE HORN-DESC-F (RARG)
\end_layout

\begin_layout Plain Layout

    <COND (<EQUAL? .RARG ,M-OBJDESC?>
\end_layout

\begin_layout Plain Layout

           <RTRUE>)
\end_layout

\begin_layout Plain Layout

;"subsequent clauses must be due to an M-OBJDESC call"
\end_layout

\begin_layout Plain Layout

          (,HORN-MOUNTED
\end_layout

\begin_layout Plain Layout

           <TELL " A brass bike horn is mounted on the
\end_layout

\begin_layout Plain Layout

bicycle handlebars.">
\end_layout

\begin_layout Plain Layout

           <COND (<EQUAL? ,HERE ,MAGIC-BIKEPATH>
\end_layout

\begin_layout Plain Layout

                  <TELL " The horn is glowing with a
\end_layout

\begin_layout Plain Layout

gentle yellow light.">)>
\end_layout

\begin_layout Plain Layout

           <CRLF>)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <TELL " A brass bicycle horn is lying here.
\end_layout

\begin_layout Plain Layout

You can almost here it saying, /"Mount me on a pair of
\end_layout

\begin_layout Plain Layout

handlebars!/"" CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice how this routine handles several different cases: whether the horn
 is mounted on the handlebars or not, and if so, whether it is glowing due
 to the presence of the Magic Bikepath.
\end_layout

\begin_layout Standard
Also note the spaces at the beginning of the TELLs in the DESCFCN.
 If your describers are of the indentation flavor, your DESCFCN must supply
 its own indentation.
\end_layout

\begin_layout Standard
Finally, notice the first clause in the COND.
 The describers call the DESCFCN twice.
 The first time is just to ask whether the DESCFCN will be describing the
 object at the present time.
 At this point, the DESCFCN is called with the argument M-OBJDESC?.
 The second time is to tell the DESCFCN to go ahead and do the describing.
 In this case, the DESCFCN is called with M-OBJDESC.
 (The difference in argument names, for maximal confusion, is simply the
 terminating question mark.) In the case of HORN-DESC-F, the DESCFCN describes
 the horn in all cases.
 However, if you wrote HORN-DESC-F to describe the horn only when mounted
 on the handlebars, the M-OBJDESC? clause would have to RFALSE whenever
 the horn wasn't mounted, telling the describers, "Go ahead and describe
 the horn; I'm not planning on describing the horn under current conditions."
 The routine would then look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE HORN-DESC-F (RARG)
\end_layout

\begin_layout Plain Layout

    <COND (<EQUAL? .RARG ,M-OBJDESC?>
\end_layout

\begin_layout Plain Layout

           <COND (,HORN-MOUNTED
\end_layout

\begin_layout Plain Layout

                  <RTRUE> ;"I'll describe the horn")
\end_layout

\begin_layout Plain Layout

                 (T
\end_layout

\begin_layout Plain Layout

                  <RFALSE> ;"you describe the horn")>)
\end_layout

\begin_layout Plain Layout

;"subsequent clauses must be due to an M-OBJDESC call"
\end_layout

\begin_layout Plain Layout

          (,HORN-MOUNTED
\end_layout

\begin_layout Plain Layout

           <TELL " A brass bike horn is mounted on the
\end_layout

\begin_layout Plain Layout

bicycle handlebars.">
\end_layout

\begin_layout Plain Layout

           <COND (<EQUAL? ,HERE ,MAGIC-BIKEPATH>
\end_layout

\begin_layout Plain Layout

                  <TELL " The horn is glowing with a
\end_layout

\begin_layout Plain Layout

gentle yellow light.">)>
\end_layout

\begin_layout Plain Layout

           <CRLF>)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <RFALSE>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Useful but Dangerous NDESCBIT
\end_layout

\begin_layout Standard
Normally, all visible objects will appear when the describers provide a
 room description.
 If you don't want a particular object described, you must give it a flag
 called the NDESCBIT.
 This flag simply tells the describers to skip over that object.
\end_layout

\begin_layout Standard
The most common use of an NDESCBIT is for an object which is already described
 in the room description.
 For example, if you had a room with a water fountain, and the water fountain
 was mentioned in the room's LDESC, or its M-LOOK clause, but the water
 fountain object didn't have the NDESCBIT, this would happen:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

Hallway
\end_layout

\begin_layout Plain Layout

    You are in a short hallway between the kindergarten
\end_layout

\begin_layout Plain Layout

classrooms to the north and the principal's office to
\end_layout

\begin_layout Plain Layout

the south.
 A water fountain is nestled in a shallow
\end_layout

\begin_layout Plain Layout

alcove, its cooling system humming quietly.
\end_layout

\begin_layout Plain Layout

    You can see a water fountain here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You might also give the NDESCBIT to a takeable object (as opposed to a permanent
 feature of a room) provided that the takeable object is described by the
 room at first.
 If you do this, however, you must make sure that the room stops describing
 the object once it is gone, and that the NDESCBIT is cleared any time the
 object is moved.
 (For example, you should give such an object the TRYTAKEBIT to prevent
 it from being acquired by an implicit take.)
\end_layout

\begin_layout Chapter
Some Complicated Stuff 
\begin_inset Newline newline
\end_inset

That You Don't Want to Learn But Have To
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Some Complicated Stuff
\end_layout

\end_inset


\end_layout

\begin_layout Section
Loops
\end_layout

\begin_layout Standard
The way that ZIL code loops back on itself is through a device called a
 REPEAT.
 A REPEAT lives inside a routine, and when the routine reaches and enters
 the REPEAT, it continues to run through all the expressions in the REPEAT
 until ordered to leave it using RETURN.
 A REPEAT must always have its own argument list.
 The word "AUX" is implicitly at the beginning of a REPEAT's argument list;
 any variable in it is an auxiliary, but you don't need to explicitly include
 the "AUX." Here's an example of a simple repeat:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SET CNT 0>
\end_layout

\begin_layout Plain Layout

<REPEAT ()
\end_layout

\begin_layout Plain Layout

    <TELL "Ha">
\end_layout

\begin_layout Plain Layout

    <SET CNT <+ .CNT 1>>
\end_layout

\begin_layout Plain Layout

    <COND (<EQUAL? .CNT 5>
\end_layout

\begin_layout Plain Layout

           <TELL "!">
\end_layout

\begin_layout Plain Layout

           <RETURN>)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <TELL " ">)>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This repeat would cause the game to print "HA HA HA HA HA!" Note the RETURN,
 and where it occurs logically.
 Also note the empty argument list.
 You could substitute for the <SET CNT 0> by having an argument list that
 says ((CNT 0)), but don't worry if you don't understand that.
\end_layout

\begin_layout Standard
FIRST? and NEXT? are often used along with REPEAT.
 For instance, here's a call to a routine, and the routine itself, that
 would remove everything from a given container:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<EMPTY-CONTAINER ,BASKET>
\end_layout

\begin_layout Plain Layout

<ROUTINE EMPTY-CONTAINER (OBJ "AUX" X N)
\end_layout

\begin_layout Plain Layout

    <SET X <FIRST? .OBJ>>
\end_layout

\begin_layout Plain Layout

    <REPEAT ()
\end_layout

\begin_layout Plain Layout

        <COND (.X
\end_layout

\begin_layout Plain Layout

               <SET N <NEXT? .X>>
\end_layout

\begin_layout Plain Layout

               <MOVE .X ,HERE>
\end_layout

\begin_layout Plain Layout

               <SET X .N>)
\end_layout

\begin_layout Plain Layout

              (T
\end_layout

\begin_layout Plain Layout

               <RETURN>)>>
\end_layout

\begin_layout Plain Layout

        <TELL "You completely empty" T .OBJ "." CR>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's say that the BASKET contained TOTO and a pair of RUBY-SLIPPERS.
 In the first line of the routine, the local variable X is set to the FIRST?
 object in the basket, TOTO.
 (If there was nothing in the basket, X would be set to <> at this point.)
\end_layout

\begin_layout Standard
The routine then enters the REPEAT; the first thing the repeat does is a
 COND, which checks whether X is true; that is, whether it is set to an
 object rather than to <>.
 Since X is equal to TOTO, the predicate is true, and the local variable
 N is set to the NEXT? object in the basket, the RUBY-SLIPPERS.
 (Remember, RUBY-SLIPPERS is the NEXT? of the FIRST? object, TOTO, not the
 NEXT? of the basket itself.) After that, TOTO is moved to HERE.
 This is why N is used; once TOTO is moved to HERE, it is no longer in the
 basket, and RUBY-SLIPPERS is no longer NEXT? of TOTO.
\end_layout

\begin_layout Standard
After the MOVE, X is set to N, the RUBY-SLIPPERS.
 The COND is now done, and since there's nothing else in this REPEAT, you
 are now at the bottom of the REPEAT, and jump back to the top of the REPEAT.
 X, now the RUBY-SLIPPERS, is true.
 But NEXT? of the RUBY-SLIPPERS is <>, since there's nothing else in the
 basket, so N is set to <>.
 The RUBY-SLIPPERS are moved to HERE, and X is set to N, meaning that it
 is set to <>.
\end_layout

\begin_layout Standard
Once again we return to the top of the REPEAT.
 This time, the predicate is false, so we go instead to the second clause
 of the COND.
 Since X was false, the basket has been completely emptied, and we RETURN
 from the REPEAT.
 Finally, the routine does a TELL before finishing its task.
\end_layout

\begin_layout Standard
At any point in a REPEAT, you can return to the top of the REPEAT by invoking
 <AGAIN>.
 <AGAIN>, when used outside of a REPEAT, simply sends you back to the top
 of the current routine.
\end_layout

\begin_layout Section
Property Manipulation
\end_layout

\begin_layout Standard
Properties, such as LDESC and SIZE, aren't just static storehouses of informatio
n that you set in stone when you define a room or object.
 They can be changed on the fly, just like flags or global variables.
\end_layout

\begin_layout Standard
The way to get at the information contained in a particular object's property
 is with the GETP command (as in GET Property).
 You must supply the name of the object and the name of the property (prefaced
 by ,P?).
 Here are some examples:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<GETP ,HERE ,P?DOWN>
\end_layout

\begin_layout Plain Layout

<GETP ,OMARS-TENT ,P?LDESC>
\end_layout

\begin_layout Plain Layout

<GETP ,PRSO ,P?SIZE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here's how each of those GETPs might appear in context:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<GETP ,HERE ,P?DOWN>
\end_layout

\begin_layout Plain Layout

       <TELL "A stair leads to a deeper part of the
\end_layout

\begin_layout Plain Layout

maze." CR>)>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<TELL "The camel lumbers into the tent; you dismount."
\end_layout

\begin_layout Plain Layout

CR CR>
\end_layout

\begin_layout Plain Layout

<MOVE ,CAMEL ,OMARS-TENT>
\end_layout

\begin_layout Plain Layout

<MOVE ,PLAYER ,OMARS-TENT>
\end_layout

\begin_layout Plain Layout

<TELL "Omar's Tent" CR <GETP ,OMARS-TENT ,P?LDESC>>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<SET FODDER-SIZE <GETP ,PRSO ,P?SIZE>>
\end_layout

\begin_layout Plain Layout

<COND (<G? .FODDER-SIZE 10>
\end_layout

\begin_layout Plain Layout

       <TELL "The " D ,PRSO " doesn't fit into the
\end_layout

\begin_layout Plain Layout

cannon." CR>)
\end_layout

\begin_layout Plain Layout

      (T
\end_layout

\begin_layout Plain Layout

       <MOVE ,PRSO ,CANNON>
\end_layout

\begin_layout Plain Layout

       <TELL "The " D ,PRSO " falls into the cannon's
\end_layout

\begin_layout Plain Layout

barrel." CR>)>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The way you change the information in a property is using the PUTP command
 (as in PUT Property).
 This is just like GETP, except that you also have to supply the value that
 you want to put into that property:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PUTP ,OMARS-TENT ,P?LDESC "This once-fine tent is now
\end_layout

\begin_layout Plain Layout

ruined -- tent poles knocked down, canvas sagging, the
\end_layout

\begin_layout Plain Layout

floor covered with camel excrement, and a foul camel
\end_layout

\begin_layout Plain Layout

odor pervading every corner.">
\end_layout

\begin_layout Plain Layout

<PUTP ,PRSO ,P?SIZE 1>
\end_layout

\begin_layout Plain Layout

<PUTP ,PROTAGONIST ,P?ACTION ,HYPNO-CASE-F>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In practice, these PUTPs might look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<MOVE ,PLAYER ,OMARS-TENT>
\end_layout

\begin_layout Plain Layout

<MOVE ,CAMEL ,OMARS-TENT>
\end_layout

\begin_layout Plain Layout

<PUTP ,OMARS-TENT ,P?LDESC "This once-fine tent is now
\end_layout

\begin_layout Plain Layout

ruined -- tent poles knocked down, canvas sagging, the
\end_layout

\begin_layout Plain Layout

floor covered with camel excrement, and a foul camel
\end_layout

\begin_layout Plain Layout

odor pervading every corner.">
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<MOVE ,PRSO ,MINIATURIZER>
\end_layout

\begin_layout Plain Layout

<PUTP ,PRSO ,P?SIZE 1>
\end_layout

\begin_layout Plain Layout

<TELL "As you place" D ,PRSO " in the miniaturizer, it
\end_layout

\begin_layout Plain Layout

shrinks to a fraction of its former size." CR>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<TELL "You stare at the doctor's swinging stopwatch,
\end_layout

\begin_layout Plain Layout

and feel yourself falling into a trance...">
\end_layout

\begin_layout Plain Layout

<PUTP ,PROTAGONIST ,P?ACTION ,HYPNO-CASE-F>
\end_layout

\end_inset


\end_layout

\begin_layout Section
Tables
\end_layout

\begin_layout Standard
A table is just a tool for storing information, like a global variable.
 Unlike a global variable, it can store more than one piece of information.
 Here's what a simple table might look like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<CONSTANT MAZE-EXITS
\end_layout

\begin_layout Plain Layout

 <TABLE 12 18 24 0 0 0>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This table has six elements.
 I'm sure you'll find it intuitively obvious that the first element is element
 number 0, and that the last element is therefore element number 5.
 In other words, MAZE-TABLE is currently storing the number 12 in its zeroth
 slot, the number 18 in its first slot, etc.
\end_layout

\begin_layout Standard
The way to get information from a table is with the GET command:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<GET ,MAZE-EXITS 0>
\end_layout

\begin_layout Plain Layout

<GET ,MAZE-EXITS 4>
\end_layout

\begin_layout Plain Layout

<GET ,MAZE-EXITS .MAZE-ROOM-NUM>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first of these GETs will return element number 0 from the table, which
 is 12.
 The second GET returns element number 4, which is 0.
 The value returned by the last GET will depend on the value of the local
 variable MAZE-ROOM-NUM.
 The way to put information into a table is with PUT:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PUT ,MAZE-EXITS 3 99>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After executing this PUT, MAZE-EXITS will now look like:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<CONSTANT MAZE-EXITS
\end_layout

\begin_layout Plain Layout

 <TABLE 12 18 24 99 0 0>>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Elements in a table can be almost anything: numbers, strings, names of objects,
 and so on.
\end_layout

\begin_layout Standard
There are several kinds of tables: PTABLEs are stored outside of the game's
 pre-load; LTABLEs tell the compiler to create a 0th element whose value
 is the number of elements in the table; PLTABLEs have both features.
 You probably won't need to understand any of this until you're well into
 your first game.
\end_layout

\begin_layout Section
Generics
\end_layout

\begin_layout Standard

\emph on
[Stu, I think that you should write this section.]
\end_layout

\begin_layout Section
Other Information You Can Obtain from the Parser
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Information from Parser
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\emph on
[Stu, I think that you should write this section.]
\end_layout

\begin_layout Chapter
New Kids on the Block – Graphics and Sound
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Graphics and Sound
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Basic Organization
\end_layout

\begin_layout Standard
Up to now, everything you've written will end up in a single file, usually
 referred to as the game file.
 In a game with graphics, however, all the graphics will live in a separate
 file, usually referred to as the picture file.
 The picture file can be thought of as a collection of graphics which the
 game can reach into and grab pictures from at any time, using the DISPLAY
 instruction.
\end_layout

\begin_layout Standard
The game file, at least in theory, will be identical from version to version.
 The Apple II, Amiga, and IBM versions should all have the same game file.
 The information in the game file is said to be machine independent.
 However, since the graphics capabilities of these machines vary so widely,
 they will all have a different version of the picture file.
 In fact, a given version might have more than one picture file.
 The Mac version of the game will probably have two: a color picture file
 for Mac IIs, and a black-and-white picture file for all other Macs.
 The IBM version might have three picture files for the various IBM graphics
 configurations.
\end_layout

\begin_layout Standard
In addition to pictures, a picture file also contains something called invisible
 pictures.
 These are basically just a pair of numbers, an X-value and a Y-value, and
 are used to decide where to display a picture.
 Since this information is machine-dependent, it must live in the picture
 file so that it can be tailored to each machine version.
\end_layout

\begin_layout Section
The DISPLAY Command
\end_layout

\begin_layout Standard
To put a graphic up on the screen, you must use the DISPLAY command.
 DISPLAY is supplied with a picture and with a point on the screen; it then
 puts the picture up on the screen with its upper-left corner at the supplied
 point.
 DISPLAY takes three arguments: the picture to be displayed, and the Y and
 X co-ordinates of the point on the screen.
 To guarantee excrutiating confusion, the Y-value comes before the X-value.
 Example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<DISPLAY ,P-LIV-RM 12 1>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will display P-LIV-ROOM, which is presumably a picture of the Living
 Room, at Y=12 and X=1.
\end_layout

\begin_layout Standard
In almost every case, however, a picture is displayed at a different point
 depending on the machine version.
 This is the purpose of those invisible pictures.
 Before displaying the picture, you must get the X and Y info from the appropria
ted invisible picture using the PICINF command (for PICture INFormation).
 PICINF takes two arguments, the name of the invisible picture, and the
 name of a table to put the information in.
 There is a table called PICINF-TBL for this purpose:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PICINF ,LR-LOC ,PICINF-TBL>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Y value of LR-LOC is now stored in the 0 slot of PICINF-TBL, and the
 X value is now stored in the 1 slot.
\end_layout

\begin_layout Standard
Now, you must add 1 to each value.
 The reason is too complicated to go into here.
 (This is only the case if you are displaying a picture relative to the
 top left corner of the screen.
 If you are displaying a picture relative to some previously displayed picture,
 or some previously determined point on the screen, then don't add 1 to
 each value.)
\end_layout

\begin_layout Standard
Therefore, the DISPLAY might look like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PICINF ,LR-LOC ,PICINF-TBL>
\end_layout

\begin_layout Plain Layout

<SET Y <+ <GET ,PICINF-TBL 0> 1>>
\end_layout

\begin_layout Plain Layout

<SET X <+ <GET ,PICINF-TBL 1> 1>>
\end_layout

\begin_layout Plain Layout

<DISPLAY ,P-LIV-ROOM .Y .X>
\end_layout

\begin_layout Plain Layout

.c2.13.3
\end_layout

\end_inset


\end_layout

\begin_layout Section
Sound and Music
\end_layout

\begin_layout Standard

\emph on
[Beats the heck out of me! I've never done diddly-squat with sound!]
\end_layout

\begin_layout Chapter
Organizing Your ZIL Files
\end_layout

\begin_layout Section
History and Theory
\end_layout

\begin_layout Standard
In the distant misty reaches of time, games were organized into two files.
 One was called ACTIONS.ZIL and contained all the action routines and other
 associated routines; the other was called DUNGEON.ZIL and contained all
 the room and object definitions.
 (As you can tell from the latter name, all the early games were some flavor
 of 
\noun on
Zork
\noun default
).
\end_layout

\begin_layout Standard
Nowadays, files of game source code can be divided up almost any way you
 please.
 In theory, you could have all the code in one single giant humongo quivering
 file.
 However, there are many reasons to divide it up into smaller chunks.
 For example, to make a new version of the game, you need only compile those
 file which have changed; if your game is divided into multiple source files,
 less code will need to be compiled, and the compilation will take less
 time.
 It also makes it easier to tell someone where to find a particular piece
 of your code.
 Also, if you need to make a printout of a part of the source code, you
 can print a more reasonably-sized section.
 Etc.
\end_layout

\begin_layout Standard
There's no exact answer to the question of what's the right size for a ZIL
 file.
 You don't want them to be too large, because of the reasons already mentioned.
 On the other hand, you don't want to have too many little files, because
 your directory will start to look like Oscar Madison's bedroom.
 A good rule of thumb is around 10 or 12 files (not including the parser).
 If, as you're writing the game, a particular file starts getting too bloated,
 simply break it up into two smaller files.
 Although periods in the middle of filenames have no special meaning to
 Spike, you should still name all your source code files [SOMETHING].ZIL.
 This will indicate to you, and anyone else looking through the game directory,
 exactly what files are the source code for the game.
\end_layout

\begin_layout Standard
There are three flavors of ZIL files.
 The following sections describe them, along with the conventions for dividing
 games and for naming ZIL files.
\end_layout

\begin_layout Section
The Parser
\end_layout

\begin_layout Standard
The parser is a black box of ZIL files.
 They don't live in the directory with the other game files; everyone shares
 the same set of parser files, which live in a separate parser directory.
 And you can't touch the parser files.
 Ever.
\end_layout

\begin_layout Section
The Substrate
\end_layout

\begin_layout Standard
The substrate refers to the basic core of objects, routines, and syntaxes
 which are common to almost every game.
\end_layout

\begin_layout Standard
When you begin writing a game, you (or your mentor) will take a recent game
 and "strip away" everything that is special to that game, leaving you with
 a vanilla shell.
 This shell is the substrate, upon which you begin writing your new game.
 Here's a recap of the ZIL files which would commonly compose the substrate
 of a recent ZIL game:
\end_layout

\begin_layout Standard
The SYNTAX.ZIL file contains several hundred syntax definitions, along with
 verb and preposition synonym lists.
\end_layout

\begin_layout Standard
The VERBS.ZIL file contains all the verb default routines for the verbs defined
 in the syntax file.
 Also, it usually contains a bunch of utility routines, such as the describers,
 JIGS-UP, etc.
\end_layout

\begin_layout Standard
The GLOBALS.ZIL file contains the object definitions (and associated action
 routines) for those global and local-global objects which appear in almost
 every game: PROTAGONIST, GROUND, HANDS, STAIRS, etc.
\end_layout

\begin_layout Standard
The HINTS.ZIL file contains the vast tables of strings which make up your
 on-line hints.
 The code for the on-line hints is in a file called CLUES.ZIL which, like
 the parser files, doesn't live in the game's directory.
 It lives in a directory called ZILLIB (for ZIL LIBrary).
\end_layout

\begin_layout Standard
The INPUT.ZIL file is where all the code associated with reading the player's
 input lives.
 A lot of this file is devoted to the code for user-definable function keys.
\end_layout

\begin_layout Standard
The MISC.ZIL file contains a whole bunch of random substrate stuff that doesn't
 belong anywhere else.
 These include macros, which are like routines, only different.
 Few understand them.
 TELL is an example of a macro.
 The misc file is also the home of CLOCKER and other interrupt-related routines.
\end_layout

\begin_layout Section
Your Game Files
\end_layout

\begin_layout Standard
The rest of the ZIL files are the stuff which makes your game, well, your
 game — and not 
\noun on
Zork III
\noun default
 or 
\noun on
Plundered Hearts
\noun default
.
 How you organize these files is up to you, but here are some common ways:
\end_layout

\begin_layout Standard
You can divide the game up geographically.
 For example, Planetfall has two files, one for each of the two island complexes.
 (The stuff aboard the ship, at the beginning of the game, lives in the
 GLOBALS file.) For another example, 
\noun on
Leather Goddesses
\noun default
 divided the game up between files for Earth, Phobos, Mars, Venus, Outer
 Space, and Cleveland.
\end_layout

\begin_layout Standard
Most of the mysteries are divided up into files called People, Places, and
 Things.
 The first contains actors and their associated code; the second, rooms;
 and the last contains all the remaining objects.
\end_layout

\begin_layout Standard
If your game tends to divide into "scenes," that would be a good way to
 divide the code.
 Any one element of the game with a lot of code can be put in a separate
 file: for example, the file MAGIC.ZIL in Enchanter contains all the code
 for learning and casting spells.
\end_layout

\begin_layout Chapter
Fireworks Time – Compiling Your Game
\end_layout

\begin_layout Chapter
Using ZIL for Other Types of Games
\end_layout

\begin_layout Section*
EXERCISE THREE
\end_layout

\begin_layout Standard
Design and implement a full-size game.
 Submit it to testing, fix all the resulting bugs, help marketing design
 a package, ship the game, and sell at least 250,000 units.
\end_layout

\begin_layout Addchap
Appendix A: Properties
\end_layout

\begin_layout Standard
Properties are what make up the object definitions for objects and rooms.
 The information in a property can be gotten using GETP (or GETPT) and changed
 using PUTP (or PUTPT).
\end_layout

\begin_layout Standard
This is a list of those object properties which appear in many games.
 Additional properties can be created for your game if you need them.
 There is a limit of 64 properties in YZIP.
\end_layout

\begin_layout Description
NORTH,
\begin_inset space ~
\end_inset

SOUTH,
\begin_inset space ~
\end_inset

EAST,
\begin_inset space ~
\end_inset

WEST,
\begin_inset space ~
\end_inset

NE,
\begin_inset space ~
\end_inset

SE,
\begin_inset space ~
\end_inset

NW,
\begin_inset space ~
\end_inset

SW: These are the direction properties, generally used only in room definitions.
 For the various types of direction properties, see section 2.2.
 Note that the cardinal direction properties are not abbreviated, but that
 the non-cardinal ones are abbreviated.
 There is no direction property called NORTHEAST, for example.
\end_layout

\begin_layout Description
UP,
\begin_inset space ~
\end_inset

DOWN: These are just like the eight direction properties.
\end_layout

\begin_layout Description
IN,
\begin_inset space ~
\end_inset

OUT: These are just like the eight direction properties.
 If the player just types IN or OUT, this property will handle the movement.
 Generally, it's a good idea to give the OUT property to any room with only
 one exit.
\end_layout

\begin_layout Description
SYNONYM: Contains a list of the nouns which can be used to refer to the
 object.
\end_layout

\begin_layout Description
ADJECTIVE: Contains a list of the adjectives which can be used to refer
 to the object.
\end_layout

\begin_layout Description
ACTION: Defines the action routine associated with the object.
 In the case of an object, the action routine is called when the object
 is the PRSO or the PRSI of the player's input.
 In the case of a room, the routine is called with M-BEG and M-END once
 each turn, with M-ENTER whenever the room is entered, and with M-LOOK whenever
 the describers need to describe the room.
\end_layout

\begin_layout Description
DESCFCN: Defines the routine which the describers use to describe the object.
 This can be the same routine as the object's action routine, provided that
 the routine is set up to handle the optional variable (M-OBJDESC or M-OBJDESC?).
 See section 11.5.
\end_layout

\begin_layout Description
CONTFCN: I never use this, why should you?
\end_layout

\begin_layout Description
GENERIC: Defines the routine which handles cases where the parser determines
 an ambiguity about which object the player is referring to.
 In the absence of a generic property, the parser will simply ask "Which
 FOO do you mean..."
\end_layout

\begin_layout Description
DESC: Technically, this isn't a property, but it looks just like one when
 you define an object.
 It contains the string which, in the case of objects,will be used in verb
 defaults, player's inventory, etc.
 In the case of rooms, it is the room name which appears before room description
 and on the status line.
\end_layout

\begin_layout Description
SDESC: Using this property is the only way to give an object a changable
 DESC.
 You can't 
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PUTP .OBJECT ,P?DESC "new desc">
\end_layout

\end_inset

 but you can 
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PUTP .OBJECT ,P?SDESC "new desc">
\end_layout

\end_inset

 Be warned, however, that if your game "shell" isn't set up for SDESCs,
 you will have to change every verb default.
 Also, be warned that doing this will increase the size of your game by
 hundreds of bytes or more, since the verb defaults will no longer simply
 TELL the desc of the object, but must instead call a little routine which
 decides whether the object in question has an SDESC or not.
\end_layout

\begin_layout Description
LDESC: In the case of a room, this contains a string which the describers
 use for the long description of the room.
 In the case of an object, this contains a string which the describers use
 to describe the object if it is on the ground.
\end_layout

\begin_layout Description
FDESC: This property, which isn't usually used in room definitions, contains
 a string which the describers use to describe the object before the first
 time it is moved.
\end_layout

\begin_layout Description
LOC: Once again, technically not a property, but it looks just like one
 when you're creating an object.
 Simply, this property contains the name of the object which contains this
 object (in the case of a room, this is the object ROOMS).
\end_layout

\begin_layout Description
SIZE: Contains a number which is the size/weight of the object.
 Generally, it is only meaningful for a takeable object.
 If a takeable object has no size property, the game usually gives it a
 default size of 5.
 The size of an object affects the number of object that a player can carry,
 how much of a container it takes up, and so on.
\end_layout

\begin_layout Description
CAPACITY: Contains a number which is the capacity of the object.
 Generally, it is only meaningful for a container.
 If a container has no size property, the game usually gives it a default
 capacity of 5.
 The capacity of a container affects the number of objects which can be
 placed inside it.
\end_layout

\begin_layout Description
VALUE: This property is used in many games that have scoring.
 The property contains a number; in the case of rooms, it is the number
 of points the player gets for entering the room for the first time; in
 the case of objects, it is the number of points the player gets for picking
 up the object for the first time.
\end_layout

\begin_layout Description
GLOBAL: Generally found only in room definitions, this property contains
 a list of objects which are local-globals referencable in that room.
\end_layout

\begin_layout Description
OWNER: Defines an object which is the owner of this object.
 For example, the SPORTS-CAR object might have the property
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

(OWNER CYBIL)
\end_layout

\end_inset

 so that the player could refer to the car as "Cybil's car" even though
 Cybil isn't actually holding the car.
 When Cybil sells the car to the player, you would 
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PUTP ,SPORTS-CAR ,P?OWNER ,PROTAGONIST>
\end_layout

\end_inset

 so that the player could now refer to it as "my car."
\end_layout

\begin_layout Description
TEXT: This property contains a string which is used when the player tries
 to read the object.
 It exists for those objects which would otherwise need an action routine
 to handle READ but nothing else.
\end_layout

\begin_layout Description
THINGS: Formerly known as the PSEUDO property, this property allows you
 to create "pseudo-objects" with some of the properties of real objects.
 They have three parts: a list of adjectives, a list of nouns, and an action
 routine.
 Here's an example: 
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

(THINGS (RED CARMINE) (SCARF ASCOT) RED-SCARF-F)
\end_layout

\end_inset

Pseudo objects are very limited, however.
 They cannot have flags, and they cannot be moved.
 It is beneficial to use them whenever feasible, because (unlike real objects)
 they take up no pre-load space.
\end_layout

\begin_layout Description
ADJACENT: Something to do with adjacent rooms and referencability.
 Stu?
\end_layout

\begin_layout Description
PLURAL: Stu?
\end_layout

\begin_layout Description
PICTURE: Contains the name of a graphic from the picture file associated
 with the room or object.
\end_layout

\begin_layout Description
FLAGS: This is another fellow which looks just like a property but isn't
 actually a property.
 It contains a list of all the flags which are FSET in that object at the
 start of the game.
 A list of the common flags can be found in the next appendix.
\end_layout

\begin_layout Addchap
Appendix B: Flags
\end_layout

\begin_layout Standard
Flags are the method for keeping track of the characteristics of an object
 or room.
 The starting characteristics of an object are defined in the object's FLAGS
 property.
 A flag can be set using FSET, cleared using FCLEAR, and checked using FSET?
\end_layout

\begin_layout Standard
This is a list of flags which appear in many games.
 Additional flags can be added to your game if you need them.
 There is a limit of 48 [right?] flags in YZIP.
\end_layout

\begin_layout Description
TAKEBIT: One of the most basic bits, this means that the player can pick
 up and carry the object.
\end_layout

\begin_layout Description
TRYTAKEBIT: This bit tells the parser not to let the player implicitly take
 an object, as in:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

READ DECREE
\end_layout

\begin_layout Plain Layout

[taking the decree first]
\end_layout

\end_inset

This is important if the object has a value and must be scored, or if the
 object has an NDESCBIT which must be cleared, or if you want taking the
 object to set a flag or queue a routine, or...
\end_layout

\begin_layout Description
CONTBIT: The object is a container; things can be put inside it, it can
 be opened and closed, etc.
\end_layout

\begin_layout Description
DOORBIT: The object is a door and various routines, such as V-OPEN, should
 treat it as such.
\end_layout

\begin_layout Description
OPENBIT: The object is a door or container, and is open.
\end_layout

\begin_layout Description
SURFACEBIT: The object is a surface, such as a table, desk, countertop,
 etc.
 Any object with the surfacebit should also have the CONTBIT (since you
 can put things on the surface) and the OPENBIT (since you can't close a
 countertop as you can a box).
\end_layout

\begin_layout Description
LOCKEDBIT: Tells routines like V-OPEN that an object or door is locked and
 can't be opened without proper equipment.
\end_layout

\begin_layout Description
WEARBIT: The object can be worn.
 Given to garments and wearable equipment such as jewelry or a diving helmet.
 Only means that the object is wearable, not that it is actually being worn.
\end_layout

\begin_layout Description
WORNBIT: This means that a wearable object is currently being worn.
\end_layout

\begin_layout Description
READBIT: The object is readable.
 Any object with a TEXT property should have the READBIT.
\end_layout

\begin_layout Description
LIGHTBIT: The object is capable of being turned on and off, like the old
 brass lantern from 
\noun on
Zork
\noun default
.
 However, it doesn't mean that the object is actually on.
\end_layout

\begin_layout Description
ONBIT: In the case of a room, this means that the room is lit.
 If your game takes place during the day, any outdoor room should have the
 ONBIT.
 In the case of an object, this means that the object is providing light.
 An object with the ONBIT should also have the LIGHTBIT.
\end_layout

\begin_layout Description
FLAMEBIT: This means that the object is a source of fire.
 An object with the FLAMEBIT should also have the ONBIT (since it is providing
 light) and the LIGHTBIT (since it can be extinguished).
\end_layout

\begin_layout Description
BURNBIT: The object is burnable.
 Generally, most takeable objects which are made out of wood or paper should
 have the BURNBIT.
\end_layout

\begin_layout Description
TRANSBIT: The object is transparent; objects inside it can be seen even
 if it is closed.
\end_layout

\begin_layout Description
NDESCBIT: The object shouldn't be described by the describers.
 This usually means that someone else, such as the room description, is
 describing the object.
 Any takeable object, once taken, should have its NDESCBIT cleared.
\end_layout

\begin_layout Description
INVISIBLE: One of the few bits that doesn't end in "-BIT," INVISIBLE tells
 the parser not to find this object.
 Usually, the intention is to clear the invisible at some point.
 For example, you might clear the invisible bit on the BLOOD-STAIN object
 after the player examines the bludgeon.
 Until that point, referring to the blood stain would get a response like
 "You can't see any blood stain right here."
\end_layout

\begin_layout Description
TOUCHBIT: In the case of a room, this means that the player has been to
 the room at least once.
 Obviously, no room should be defined with a TOUCHBIT, since at the beginning
 of the game, the player has not been in any room yet.
 In the case of an object, this means that the object has been taken or
 otherwise disturbed by the player; for example, once the TOUCHBIT of an
 object is set, if it has an FDESC, that FDESC will no longer be used to
 describe it.
\end_layout

\begin_layout Description
SEARCHBIT: A very slippery concept.
 It tells the parser to look as deeply into a container as it can in order
 to find the referenced object.
 Without the SEARCHBIT, the parser will only look down two-levels.
 Example.
 There's a box on the ground; there's a bowl in the box; there's an apple
 in the bowl.
 
\begin_inset Newline newline
\end_inset

If the player says TAKE APPLE, and the box or the bowl have a SEARCHBIT,
 the apple will be found by the parser and then taken.
 If the player says TAKE APPLE, and the box and bowl don't have the SEARCHBIT,
 the parser will say "You can't see any apple right here." Frankly, I think
 the SEARCHBIT is a stupid concept, and I automatically give the SEARCHBIT
 to all containers.
\end_layout

\begin_layout Description
VEHBIT: This means that the object is a vehicle, and can be entered or boarded
 by the player.
 All objects with the VEHBIT should usually have the CONTBIT and the OPENBIT.
\end_layout

\begin_layout Description
PERSONBIT: This means that the object is a character in the game, and such
 act accordingly.
 For example, they can be spoken to.
 This flag is sometimes called the ACTORBIT.
\end_layout

\begin_layout Description
FEMALEBIT: The object is an ACTOR who is a female.
 Informs various routines to say "she" instead of "he."
\end_layout

\begin_layout Description
VOWELBIT: The object's DESC begins with a vowel; any verb default which
 prints an indefinite article before the DESC is warned to use "an" instead
 of "a."
\end_layout

\begin_layout Description
NARTICLEBIT: The object's DESC doesn't not work with articles, and they
 should be omitted.
 An example is the ME object, which usually has the DESC "you." A verb default
 should say "It smells just like you." rather than "It smells just like a
 you."
\end_layout

\begin_layout Description
PLURALBIT: The object's DESC is a plural noun or noun phrase, such as "barking
 dogs," and routines which use the DESC should act accordingly.
\end_layout

\begin_layout Description
RLANDBIT: Usually used only for rooms, this bit lets any routine that cares
 know that the room is dry land (as most are).
\end_layout

\begin_layout Description
RWATERBIT: The room is water rather than dry land, such as the River and
 Reservoir in Zork I.
 Some typical implications: The player can't go there without a boat; anyone
 dropped outside of the boat will sink and be lost, etc.
\end_layout

\begin_layout Description
RAIRBIT: The room is in mid-air, for those games with some type of flying.
\end_layout

\begin_layout Description
KLUDGEBIT: This bit is used only in the syntax file.
 It is used for those syntaxes which want to be simply VERB PREPOSITION
 with no object.
 Put (FIND KLUDGEBIT) after the object.
 The parser, rather than complaining about the missing noun, will see the
 FIND KLUDGEBIT and set the PRSO (or PRSI as the case may be) to the ROOMS
 object.
 Some games use RLANDBIT instead of the KLUDGEBIT; this saves a bit, since
 the parser won't "find" a room, and no objects have the RLANDBIT.
\end_layout

\begin_layout Description
OUTSIDEBIT: Used in rooms to classify the room as an outdoors room.
\end_layout

\begin_layout Description
INTEGRALBIT: This means that the object is an integral part of some other
 object, and can't be independently taken or dropped.
 An example might be a dial or button on a (takeable) piece of equipment.
\end_layout

\begin_layout Description
PARTBIT: The object is a body part: the HANDS object, for example.
\end_layout

\begin_layout Description
NALLBIT: This has something to do with telling a TAKE ALL not to take something,
 but I don't recall how it works.
 Help???
\end_layout

\begin_layout Description
DROPBIT: Found in vehicles, this not-very-important flag means that if the
 player drops something while in that vehicle, the object should stay in
 the vehicle rather than falling to the floor of the room itself.
\end_layout

\begin_layout Description
INBIT: Another not-too-important vehicle-related flag, it tells various
 routines to say "in the vehicle" rather than "on the vehicle."
\end_layout

\begin_layout Addchap
Appendix C: Common Routines
\end_layout

\begin_layout Standard
This is a list of useful routines which you will find in many, and in some
 cases all, games.
 If you're not sure whether your substrate already has one of these routines,
 just do a hunt through all your ZIL files.
\end_layout

\begin_layout Description
GOTO: This routine takes one argument, which should be a room: 
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<GOTO ,JAIL>
\end_layout

\end_inset

It sends the player to that room, and does all the appropriate things, such
 as call the room's action routine with M-ENTER, and call the describers.
 V-WALK, the routine which normally handles all movement, calls GOTO; however,
 there are many instances when you will want to call it yourself, such as
 when the player pushes the button in the teleportation booth.
 Some games allow GOTO to work with a vehicle as well as a room.
\end_layout

\begin_layout Description
DO-WALK: Takes one argument, which is a direction: 
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<DO-WALK ,P?WEST>
\end_layout

\end_inset

The game will now attempt to walk the player in that direction.
 Notice the difference between GOTO and DO-WALK.
 DO-WALK is just an attempt, and the response might be something like "The
 door to the west is locked." GOTO overides all that, however, and positively
 sends the player to the given room.
\end_layout

\begin_layout Description
JIGS-UP: Takes one argument, a string: 
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<JIGS-UP "The guillotine blade descends.">
\end_layout

\end_inset

This is the routine that "kills" the player.
 Most games follow the supplied string with a message like
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

*** You have died.
 ***
\end_layout

\end_inset

Some games allow for several "resurrections." All games should follow a death
 with an opportunity to RESTART or RESTORE.
\end_layout

\begin_layout Description
THIS-IS-IT: Takes one argument, an object:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<THIS-IS-IT ,GOLDEN-ARROW>
\end_layout

\end_inset

Normally, IT is set to the most recent PRSO.
 For example, if the input was SHOOT THE BOW AT THE CENTER TARGET, then
 the current IT would be BOW—that is, DROP IT as the next input would be
 taken to mean DROP BOW.
 Calling THIS-IS-IT allows you to change IT.
 You might want to do this if some action or description in the output highlight
ed a particular object.
 The example above might occur after a bit of text like, "The Sheriff of
 Nottingham hands you the grand prize, a golden arrow."
\end_layout

\begin_layout Description
INIT-STATUS-LINE: Takes an optional argument of T:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<INIT-STATUS-LINE T>
\end_layout

\end_inset

This sets up the status line, which fills the top of the screen in most
 IF games.
 For a fairly typical status line, this routine would draw a couple of lines
 in inverse video, and then print "Location:" and "Score:" and "Moves:"
 in the appropriate places.
 INIT-STATUS-LINE can be modified to your hearts content to make your own
 status line as austere or baroque as you please.
 The optional T tells INIT-STATUS-LINE not to clear the entire screen before
 going to work.
\end_layout

\begin_layout Description
UPDATE-STATUS-LINE: Usually takes no arguments:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<UPDATE-STATUS-LINE>
\end_layout

\end_inset

This is the natural partner of INIT-STATUS-LINE.
 Whereas INIT-STATUS-LINE is usually called only at the beginning of the
 game, or when the screen is cleared for some reason, UPDATE-STATUS-LINE
 gets called just about every turn.
 It changes the room name, if needed, and the score, if needed, and updates
 the number of moves, and anything else that's called for on your special
 little status line.
\end_layout

\begin_layout Description
ITALICIZE: Takes one argument, a string:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ITALICIZE "oy gevalt">
\end_layout

\end_inset

Causes the string to be appear in italics rather than in the normal font.
 On those machines which don't support italics (that is, most) the string
 will appear underlined.
\end_layout

\begin_layout Description
GAME-VERB?: Takes no arguments:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<GAME-VERB?>
\end_layout

\end_inset

This routine, as you would expect by the trailing question mark in the title,
 is used as a predicate.
 It returns true if PRSA is one of a list of verbs that don't take a turn.
 Some examples of such verbs are VERBOSE, SCRIPT, and $VERIFY.
 You might create such a verb over the course of writing a game; if so,
 don't forget to add it to the GAME-VERB? list.
\end_layout

\begin_layout Description
ROB: Takes one argument, an object, as well as an optional argument, which
 could be a room or and object:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROB ,MONTY-HALL ,BOX-BEHIND-CURTAIN-TWO>
\end_layout

\end_inset

ROB empties the supplied object—that is, it moves everything whose LOC is
 that object.
 If the optional argument is supplied, ROB moves the contents of the object
 to there.
 If no optional destination is supplied, ROB simply removes the contents
 (leaving the contents in limbo, without a LOC).
\end_layout

\begin_layout Description
WEIGHT: Takes one argument, usually an object:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<WEIGHT ,SANTA-SACK>
\end_layout

\end_inset

Determines the total size of a container by adding its own SIZE to the SIZEs
 of any objects within the container, going recursively down as many levels
 as necesary.
\end_layout

\begin_layout Description
PICK-ONE: Takes one argument, the name of a table:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PICK-ONE ,SNIDE-COMEBACKS>
\end_layout

\end_inset

Randomly picks one element from the supplied table.
 There are two flavors of PICK-ONE around.
 The older version picks a random element each time it is called.
 The more modern version "remembers" which elements have been previous returned,
 and won't repeat an element until every element in the table has been returned
 once.
 Most commonly, this routine is used along with a table of strings in order
 to give variety to a common response.
 For example, since taking untakeable objects is so common, the V-TAKE default
 is a PICK-ONE from a table called YUKS which includes such classic responses
 as "Not bloody likely." and "What a concept!"
\end_layout

\begin_layout Description
VISIBLE?: Takes one argument, an object:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<VISIBLE? ,SECRET-DOOR>
\end_layout

\end_inset

This routine, which is used as a predicate, returns true if the supplied
 object is visible to the player; that is, if it can be currently referred
 to.
\end_layout

\begin_layout Description
ACCESSIBLE?: Takes one argument, an object:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ACCESSIBLE? ,STAR-OF-SIAM>
\end_layout

\end_inset

Similar to VISIBLE?, except that it also checks for whether the object can
 be gotten.
 For example, an object inside a closed, transparent container would be
 visible but not accessible.
\end_layout

\begin_layout Description
UNTOUCHABLE?: Takes one argument, an object:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<UNTOUCHABLE? ,GROUNDHOG>
\end_layout

\end_inset

Another in our exciting line of predicates, UNTOUCHABLE? returns true if
 the object supplied is out of reach of the player at the current time.
 It is usually used for the case where a player is inside a vehicle and
 is interacting with an object outside the vehicle.
\end_layout

\begin_layout Description
WITHIN?: Takes four arguments, all integers:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<WITHIN? .LEFT .TOP .BOTTOM .RIGHT>
\end_layout

\end_inset

This routine determines whether the coordinates of a mouse click fall within
 a rectangle defined by the four data points supplied.
 The first two numbers are the X and Y of the top-left corner of the rectangle;
 the third and fourth numbers are the X and Y of the bottom-right corner
 of the rectangle.
\end_layout

\begin_layout Description
META-LOC: Takes one argument, and object:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<META-LOC ,FUSE-17>
\end_layout

\end_inset

This routine take the supplied object and recurses until it determines what
 room the object is currently in.
 META-LOC then returns that room.
 META-LOC will return false if the ultimate location of the supplied object
 is not a room: for example, if the object has been removed (its LOC is
 false), or if the object is inside an object which has been removed, etc.
\end_layout

\begin_layout Description
OTHER-SIDE: Takes one argument, an object which is a door:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<OTHER-SIDE ,FRONT-DOOR>
\end_layout

\end_inset

This routine returns the room on the other side of the supplied door from
 the player's current room.
 For example, if the player were on the Front Porch, OTHER-SIDE would return
 Foyer; if the player were in Foyer, OTHER-SIDE would return Front Porch.
\end_layout

\begin_layout Description
NOW-DARK?: Takes no arguments:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<NOW-DARK?>
\end_layout

\end_inset

 Despite the question mark, this is not a predicate.
 It is called when the player has just done something which might potentially
 leave him/her in the dark, such as extinguishing a light source, or closing
 a container which might contain the player's only light source.
 NOW-DARK? checks, and if it is now dark, it informs the player, and perhaps
 warns the player about grues, rats, boogey men, or whatever.
\end_layout

\begin_layout Description
NOW-LIT?: Takes no arguments:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<NOW-LIT?>
\end_layout

\end_inset

This is the counterpart of NOW-DARK? It is called when the player may have
 done something to provide light to a previously dark condition.
 It tells the describers that the player can now see and that a room description
 is in order.
\end_layout

\begin_layout Description
HELD?: Takes an argument, an object, as well as an optional argument, which
 can be either a room or an object:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<HELD? ,POISON ,DOCTOR>
\end_layout

\end_inset

If no optional argument is supplied to HELD? it assumes that the second
 argument is the PLAYER object.
 HELD? takes the first object and recurses to determine if it is ultimately
 within the second object.
 It differs from <IN? ,POISON ,DOCTOR> because that predicate will only
 be true if the POISON object has the DOCTOR object as its LOC; the HELD?
 predicate will be true even if the POISON is inside a bottle which is inside
 the black bag that the doctor is carrying.
 Some authors, who value accuracy above typing speed, call this routine
 ULTIMATELY-IN?
\end_layout

\begin_layout Description
TOUCHING?: Takes one argument, an object, and decides, based on the current
 PRSA, whether the player must "touch" the object in order to perform his
 or her action.
 Verbs such as TOUCH, TAKE, SHAKE, PUSH, and many more, all require the
 player to "touch" the PRSO; there are a few which require the player to
 "touch" the PRSI.
 Here's an example.
 The INGOT has been in the bed of coals, and is red hot.
 The INGOT's action routine would have a clause like:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<TOUCHING? ,INGOT>
\end_layout

\begin_layout Plain Layout

       <TELL "The ingot is red hot; you'd scorch your
\end_layout

\begin_layout Plain Layout

fingers.">)>
\end_layout

\end_inset

 This is obviously much better than having a long <VERB? ...> predicate each
 time you want to make a check like this.
\end_layout

\begin_layout Description
CANT-SEE: Takes an object and prints "You can't see any ...
 here." thus imitating the parser failure with the same language.
 Rather than plugging in the object's DESC, it actually uses the player's
 noun phrase, as the parser would.
 This is useful if an object is "found" by the parser but shouldn't be reference
able in the current game situation:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE PUDDLE-F ()
\end_layout

\begin_layout Plain Layout

    <COND (,AFTER-NOON
\end_layout

\begin_layout Plain Layout

           <CANT-SEE ,PUDDLE>)
\end_layout

\begin_layout Plain Layout

          (<VERB? EXAMINE>
\end_layout

\begin_layout Plain Layout

           <TELL "The warm sun is quickly drying out
\end_layout

\begin_layout Plain Layout

the puddle.
 It probably will be gone by noon." CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Description
RUNNING?: This routine takes the name of an interrupt routine and determines
 whether that routine is currently running; that is, whether it will be
 called by CLOCKER at the end of the current turn.
 Here's an example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE GAZEBO-EXIT-F ()
\end_layout

\begin_layout Plain Layout

    <COND (<RUNNING? I-RAINSTORM>
\end_layout

\begin_layout Plain Layout

           <TELL "You'd ruin your new perm!" CR>
\end_layout

\begin_layout Plain Layout

           <RFALSE>)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           ,GARDEN)>>
\end_layout

\end_inset


\end_layout

\begin_layout Description
GLOBAL-IN?: This routine takes two arguments, an object and a room, and
 returns true if the object is a local-global in that room.
 Let's say you had a room called DINING-ROOM.
 If the definition for DINING-ROOM included:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

(GLOBALS CARPET)
\end_layout

\end_inset

then
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<GLOBAL-IN? ,CARPET ,DINING-ROOM>
\end_layout

\end_inset

would be true.
 If DINING-ROOM had no GLOBALS list, or if its GLOBALS list didn't include
 CARPET, then the call to GLOBAL-IN? would be false.
 Here's another example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ROUTINE V-FILL ()
\end_layout

\begin_layout Plain Layout

    <COND (<GLOBAL-IN? ,WATER ,HERE>
\end_layout

\begin_layout Plain Layout

           <TELL "You fill" T ,PRSO " with water." CR>)
\end_layout

\begin_layout Plain Layout

          (T
\end_layout

\begin_layout Plain Layout

           <TELL "There's nothing here to fill" T ,PRSO
\end_layout

\begin_layout Plain Layout

"with!" CR>)>>
\end_layout

\end_inset


\end_layout

\begin_layout Description
SEE-INSIDE?: A small routine which takes an object — a container — and returns
 true if the player can see the contents of the container (i.e.
 is it open or transparent).
\end_layout

\begin_layout Description
CAPITAL-NOUN?: This is used by CANT-SEE and some parser routines to determine
 whether to capitalize a word when repeating back a noun from the player's
 input, and whether "any" should appear before it:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

[You can't see Cincinatti here.]
\end_layout

\begin_layout Plain Layout

[Which Elvis do you mean, Elvis Presley or Elvis
\end_layout

\begin_layout Plain Layout

Costello?]
\end_layout

\end_inset

rather than
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

[You can't see any cincinatti here.]
\end_layout

\begin_layout Plain Layout

[Which elvis do you mean, Elvis Presley or Elvis
\end_layout

\begin_layout Plain Layout

Costello?]
\end_layout

\end_inset

Whenever you create a vocabulary word that should be capitalized, be sure
 to add it to the list or words in CAPITAL-NOUN?.
\end_layout

\begin_layout Description
FIND-IN: If you pass this routine a location and the name of a flag, it
 will return the one object there which has that flag.
 If there are no objects in that location with that flag, or if there are
 more than one object with that flag, FIND-IN will return false.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<SET PREY <FIND-IN ,TRAP ,ANIMALBIT>>
\end_layout

\begin_layout Plain Layout

       <TELL "A " D .PREY " is caught in the trap,
\end_layout

\begin_layout Plain Layout

whimpering pitifully." CR>)>
\end_layout

\end_inset

Optionally, FIND-IN takes a string.
 If supplied with a string, FIND-IN will print the string and the found-object
 in brackets before the normal response, simulating what the parser does
 when it does a FIND.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COND (<AND <VERB? UNLOCK>
\end_layout

\begin_layout Plain Layout

            <NOT ,PRSI>
\end_layout

\begin_layout Plain Layout

       <SET KEY <FIND-IN ,PLAYER ,KEYBIT "with">>>
\end_layout

\begin_layout Plain Layout

       <TELL "You unlock the door with" TR .KEY>)>
\end_layout

\end_inset

would produce:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

>UNLOCK DOOR
\end_layout

\begin_layout Plain Layout

[with the purple key]
\end_layout

\begin_layout Plain Layout

You unlock the door with the purple key.
\end_layout

\end_inset


\end_layout

\begin_layout Addchap
Appendix D: ZIL Instructions
\end_layout

\begin_layout Standard
ZIL instructions, also called op-codes, are the method by which you communicate
 with the interpreter.
 This is just a partial list; some op-codes are so obscure you'll never
 need to know them.
 A complete description of every instruction can be found in the ZIP Specificati
on.
\end_layout

\begin_layout Standard
In the list below, arguments to the instruction are listed after the name
 of the instruction.
 Optional arguments are italicized.
\end_layout

\begin_layout Addsec
Arithmetic Instructions
\end_layout

\begin_layout Description
ADD integer1 integer2 
\begin_inset Newline newline
\end_inset

Adds the two given numbers and returns the sum.
 This usually appears in ZIL code as a "+" — the compiler changes it to
 "ADD." Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<+ ,FRONT-SEAT-PASSENGERS ,BACK-SEAT-PASSENGERS>
\end_layout

\end_inset


\end_layout

\begin_layout Description
SUB integer1 integer2
\begin_inset Newline newline
\end_inset

Subtracts integer2 from integer1 and returns the difference.
 The compiler changes "-" to "SUB." Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<- ,LT-BLATHER-ANGER 5>
\end_layout

\end_inset


\end_layout

\begin_layout Description
MUL integer1 integer2
\begin_inset Newline newline
\end_inset

Multiplies the two given numbers and returns the product.
 The compiler changes "*" to "MUL." Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

 <* <MARTIANS-IN-ROOM> ,ANTENNA-ON-A-MARTIAN>
\end_layout

\end_inset


\end_layout

\begin_layout Description
DIV integer1 integer2
\begin_inset Newline newline
\end_inset

Divides integer1 by integer2 and returns the quotient, truncated to an integer
 if necessary.
 The compiler changes "/" to "DIV." Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

</ ,SCREEN-WIDTH 2>
\end_layout

\end_inset


\end_layout

\begin_layout Description
MOD integer1 integer2
\begin_inset Newline newline
\end_inset

Divides integer1 by integer2 and returns the remainder.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<MOD ,PEBBLES-IN-PILE 10>
\end_layout

\end_inset


\end_layout

\begin_layout Description
RANDOM integer
\begin_inset Newline newline
\end_inset

Returns a random number between one and the given number, inclusive.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<RANDOM 17>
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
Predicate Instructions
\end_layout

\begin_layout Description
EQUAL? arg1 arg2 arg3 arg4
\begin_inset Newline newline
\end_inset

Returns true if arg1 is equal? to any of the subsequent args.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

 <EQUAL? ,HERE ,OVAL-OFFICE ,ROSE-GARDEN ,PORTICO>
\end_layout

\end_inset


\end_layout

\begin_layout Description
ZERO? arg
\begin_inset Newline newline
\end_inset

Returns true if the value of arg is zero.
 This often appears as
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<EQUAL? ,WHATEVER 0>
\end_layout

\end_inset

 in your game code; the compiler converts it to the ZERO? instruction.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ZERO? ,FUEL-LEVEL>
\end_layout

\end_inset


\end_layout

\begin_layout Description
LESS? integer1 integer2
\begin_inset Newline newline
\end_inset

Returns true if integer1 is less than integer2.
 The compiler converts L? to LESS?.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<L? ,AIR-PRESSURE 4>
\end_layout

\end_inset


\end_layout

\begin_layout Description
GRTR? integer1 integer2
\begin_inset Newline newline
\end_inset

Returns true if integer1 is greater than integer2.
 The compiler converts G? to GRTR?.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<G? ,GONDOLA-WEIGHT ,BALLOON-LIFTING-CAPACITY>
\end_layout

\end_inset


\end_layout

\begin_layout Description
FSET? object flag
\begin_inset Newline newline
\end_inset

Returns true if flag is set in object.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<FSET? ,BRASS-LAMP ,ONBIT>
\end_layout

\end_inset


\end_layout

\begin_layout Description
IN? object1 object2
\begin_inset Newline newline
\end_inset

Returns true if object2 is the LOC of object1.
 (NOTE: will return false if object1 is merely inside an object which is
 inside object2.) Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<IN? ,SECRET-WILL ,WALL-SAFE>
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
Object Operations
\end_layout

\begin_layout Description
MOVE object1 object2
\begin_inset Newline newline
\end_inset

Puts object1 into object2.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<MOVE ,BREAD ,TOASTER>
\end_layout

\end_inset


\end_layout

\begin_layout Description
REMOVE object1
\begin_inset Newline newline
\end_inset

Removes object, setting its LOC to false.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<REMOVE ,ICE-CUBE>
\end_layout

\end_inset


\end_layout

\begin_layout Description
LOC object1
\begin_inset Newline newline
\end_inset

Returns the location of object.
 Returns false if object has no location.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<LOC ,SMOKING-GUN>
\end_layout

\end_inset


\end_layout

\begin_layout Description
FIRST? object1
\begin_inset Newline newline
\end_inset

Returns the first object within object1.
 Returns false if object1 has no contents.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<FIRST? ,REFRIGERATOR>
\end_layout

\end_inset


\end_layout

\begin_layout Description
NEXT? object1
\begin_inset Newline newline
\end_inset

Returns the next object in the linked contents of object1's LOC.
 Returns false if object1 is the "last" object in its LOC.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<NEXT? ,MAYONNAISE>
\end_layout

\end_inset


\end_layout

\begin_layout Description
FSET object1 flag1
\begin_inset Newline newline
\end_inset

Sets flag1 in object1.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<FSET ,OILY-TORCH ,FLAMEBIT>
\end_layout

\end_inset


\end_layout

\begin_layout Description
FCLEAR object1 flag1
\begin_inset Newline newline
\end_inset

Clears flag1 in object1.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<FCLEAR ,GUARDED-DIAMOND ,TRYTAKEBIT>
\end_layout

\end_inset


\end_layout

\begin_layout Description
GETP object1 property1
\begin_inset Newline newline
\end_inset

Returns the specified property of object1.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<GETP ,HERE ,P?LDESC>
\end_layout

\end_inset


\end_layout

\begin_layout Description
PUTP object1 property1 thing 
\begin_inset Newline newline
\end_inset

Changes the value of the given object's given property to thing.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PUTP ,ROTTING-TOMATO ,P?SDESC "rotten tomato">
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
Table Operations
\end_layout

\begin_layout Description
GET table1 integer1
\begin_inset Newline newline
\end_inset

Returns the value that is stored in the integer1th slot in the given table
 table1.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<GET ,LATITUDE-TABLE 30>
\end_layout

\end_inset


\end_layout

\begin_layout Description
PUT table1 integer1 thing
\begin_inset Newline newline
\end_inset

Changes the integer1th slot of the given table to thing.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PUT ,SUSPECTS-TABLE ,SUSPECTS-POINTER ,BUTLER>
\end_layout

\end_inset


\end_layout

\begin_layout Description
INTBL? thing table1 length
\begin_inset Newline newline
\end_inset

Returns true if thing is found within the given table.
 The third argument is an integer representing the number of elements in
 the given table.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<INTBL? ,RUDOLPH ,REINDEER-TABLE 8>
\end_layout

\end_inset


\end_layout

\begin_layout Description
COPYT table1 table2 integer1
\begin_inset Newline newline
\end_inset

Copies table1 into table2.
 The process stops at the integer1th slot number; if you desire, all of
 table1 doesn't have to be copied to table2.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COPYT ,CURRENT-MOVE-TBL ,OLD-MOVE-TBL ,MOVE-TBL-LEN>
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
Input Operations
\end_layout

\begin_layout Description
READ table1 table2 integer1 routine1
\begin_inset Newline newline
\end_inset

This is the most common way for getting the player's input in an interactive
 fiction game.
 It tells the interpreter to get the player's input and store it in table1.
 The main READ, which reads the normal input following the normal prompt,
 lives in the parser and you never have to worry about it.
 However, you'll occassionally want to do a READ without going through the
 parser, such as the routine FINISH does to determine whether you want to
 restart, restore, or quit.
 Don't worry about the optional arguments.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<READ ,P-INBUF-TBL>
\end_layout

\end_inset


\end_layout

\begin_layout Description
INPUT integer1 integer2 routine1
\begin_inset Newline newline
\end_inset

Input is similar to read, except that it reads a single keystroke, rather
 than a line of text.
 The argument is a number corresponding to an input device; as of now, the
 only input device defined is the keyboard, with number 1.
 The first optional argument tells INPUT, rather than waiting forever for
 a keystroke, to wait only that many tenths of a second.
 The second optional argument is the name of a routine that INPUT should
 call if it "times out" — that is, if it gets no keystroke within the allotted
 time.
 Example: 
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<INPUT 1>
\end_layout

\end_inset


\end_layout

\begin_layout Description
MOUSE-INFO table1
\begin_inset Newline newline
\end_inset

The interpreter will put four pieces or information about the mouse into
 table1, which naturally must be at least 4 elements long.
 The four pieces of info are, in order: the y position of the mouse cursor
 (in pixels), the x position, which (if any) mouse button has been pressed,
 and the menu or menu item selected.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<MOUSE-INFO ,MOUSE-INFO-TBL>
\end_layout

\end_inset


\end_layout

\begin_layout Description
MOUSE-LIMIT window
\begin_inset Newline newline
\end_inset

You can have up to 8 windows in YZIP.
 The main, scrolling, text window is Window 0.
 Normally, the mouse is active in every window; this restricts the mouse
 to the given window.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<MOUSE-LIMIT 0>
\end_layout

\end_inset


\end_layout

\begin_layout Description
MENU integer1 table1
\begin_inset Newline newline
\end_inset

This allows you to add a menu to the menu bar (for those computers that
 have them).
 As of this writing, only the Mac interpreter has this feature implemented.
 Integer1 is the number of the menu bar slot where your menu should appear;
 this number must be greater than 2, because slot below that are reserved
 for permanent menus.
 Table1 is an LTABLE of strings for the menu; the first string should be
 the name of the menu.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<MENU 3 ,BATTLE-COMMANDS-TBL>
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
Output Operations
\end_layout

\begin_layout Description
PRINT string1
\begin_inset Newline newline
\end_inset

Prints the given string to the current window.
 Like most of the printing-related instructions that follow, the compiler
 will convert your TELLs into the appropriate set of printing instructions.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PRINT "Not bloody likely.">
\end_layout

\end_inset


\end_layout

\begin_layout Description
PRINTD object1
\begin_inset Newline newline
\end_inset

Prints the DESC of the given object.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PRINTD ,WICKER-BASKET>
\end_layout

\end_inset


\end_layout

\begin_layout Description
PRINTN integer1
\begin_inset Newline newline
\end_inset

Prints the given number.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PRINTN ,DIAL-SETTING>
\end_layout

\end_inset


\end_layout

\begin_layout Description
BUFOUT integer1
\begin_inset Newline newline
\end_inset

Tells the interpreter whether to buffer output.
 If integer1 is 1, output is buffered and sent to the screen a line at a
 time (this is the normal, default behavior).
 If integer1 is 0, all output is sent immediately to the screen without
 buffering.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<BUFOUT 0>
\end_layout

\end_inset


\end_layout

\begin_layout Description
CRLF 
\begin_inset space ~
\end_inset

 
\begin_inset Newline newline
\end_inset

Prints an end-of-line sequence.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<CRLF>
\end_layout

\end_inset


\end_layout

\begin_layout Description
HLIGHT integer1
\begin_inset Newline newline
\end_inset

Tells the interpreter how to display text, according to the following values
 of integer1: 0 - no highlighting; 1 - inverse video; 2 - bold; 4 - underline/it
alic; 8 - monospaced font.
 Constants, such as H-INVERSE and H-ITALIC exist so that you don't have
 to remember these numbers.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<HLIGHT ,H-BOLD>
\end_layout

\end_inset


\end_layout

\begin_layout Description
COLOR integer1 integer2
\begin_inset Newline newline
\end_inset

Sets the foreground and background colors according to the following values:
 -1 - color of pixel at cursor location; 0 - no change; 1 - default color;
 2 - black; 3 - red; 4 - green; 5 - yellow; 6 - blue; 7 - magenta; 8 - cyan;
 9 - white.
 The Amiga has three additional colors: 10 - light gray, 11 - medium gray;
 12 - dark gray.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<COLOR 0 ,FANUCCI-BACKGROUND>
\end_layout

\end_inset


\end_layout

\begin_layout Description
DIROUT integer1
\begin_inset Newline newline
\end_inset

Tells the interpreter to commence sending output to the specified device,
 according to the following values of integer1: 1 - screen; 2 - printer;
 3 - table; 4 - command file.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<DIROUT ,D-PRINTER-ON>
\end_layout

\end_inset


\end_layout

\begin_layout Description
DIRIN integer1
\begin_inset Newline newline
\end_inset

Tells the intepreter to commence receiving input from the specified device,
 according to the following values of integer1: 0 - keyboard; 1 - command
 file.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<DIRIN 1>
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
Window Operations
\end_layout

\begin_layout Description
CURSET integer1 integer2 integer3
\begin_inset Newline newline
\end_inset

This moves the cursor to a point on the screen corresponding to y = integer1
 (in pixels) and x = integer2.
 Integer3 is the number of the window; if not supplied, the cursor will
 move to that point in the current window.
 The only case where integer2 is optional is when integer1 is -1 or -2;
 -1 tells the interpreter to "turn off" or "hide" the cursor; -2 means to
 turn it back on.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<CURSET 1 </ ,WIDTH 2>> ;"top center of the screen"
\end_layout

\end_inset


\end_layout

\begin_layout Description
CURGET table1
\begin_inset Newline newline
\end_inset

Puts the location of the cursor into table1; the y coordinate will be element
 0 and the x coordinate will be element 1.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<CURGET ,CURSOR-LOC-TBL>
\end_layout

\end_inset


\end_layout

\begin_layout Description
SCREEN integer1
\begin_inset Newline newline
\end_inset

Moves you to the window of that number; all subsequent output will be sent
 to that window.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SCREEN 2>
\end_layout

\end_inset


\end_layout

\begin_layout Description
CLEAR integer1
\begin_inset Newline newline
\end_inset

Clears one of the 8 windows, depending on the given integer.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<CLEAR ,S-TEXT>
\end_layout

\end_inset


\end_layout

\begin_layout Description
WINPOS integer1 integer2 integer3
\begin_inset Newline newline
\end_inset

Sets the position of the integer1th window to a location on the screen identifie
d by y = integer2 (in pixels) and x = integer3.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<WINPOS ,FOOTNOTE-WINDOW 33 12>
\end_layout

\end_inset


\end_layout

\begin_layout Description
WINSIZE integer1 integer2 integer3
\begin_inset Newline newline
\end_inset

Sets the size of the integer1th window to a height of integer2 (in pixels)
 and a width of integer3.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<WINSIZE 0 ,TEXT-WINDOW-HEIGHT ,TEXT-WINDOW-WIDTH>
\end_layout

\end_inset


\end_layout

\begin_layout Description
WINATTR integer1 integer2 operation
\begin_inset Newline newline
\end_inset

Sets the characteristics of the integer1th window, according to the the
 following values of integer2: 1 - wrapping; 2 - scrolling; 4 - scripting;
 8 - buffering.
 I have no idea what "operation" means.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<WINATTR ,TEXT-WINDOW 15> ;"all four attributes"
\end_layout

\end_inset


\end_layout

\begin_layout Description
SPLIT integer1
\begin_inset Newline newline
\end_inset

Splits the screen into window 0 and window 1, with the division at a distance
 of integer1 from the top of the screen (in lines of text).
 This has the effect of simulating the old-fashioned style of pre-YZIP interacti
ve fiction.
 SPLIT is now discouraged in favor of WINPOS and WINSIZE.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SPLIT 2>
\end_layout

\end_inset


\end_layout

\begin_layout Description
MARGIN integer1 integer2 window1
\begin_inset Newline newline
\end_inset

Sets the left margin to integer1 (in pixels) and the right margin to integer2.
 This refers to the width of the margin, not its location.
 In other words, margins set to 0 and 0 would be the entire width of the
 screen (which is the default case).
\begin_inset Newline newline
\end_inset

Window1 is the window number of the window you want changes the margins
 in; if not supplied, it defaults to the current window.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<MARGIN 20 20>
\end_layout

\end_inset


\end_layout

\begin_layout Description
SCROLL integer1 integer2
\begin_inset Newline newline
\end_inset

Scrolls the integer1th window.
 If integer2 is supplied, the window will scroll by that number of text
 lines.
 If not supplied, the window will scroll one line.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SCROLL ,S-TEXT 4>
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
Pictures and Sound
\end_layout

\begin_layout Description
DISPLAY integer1 integer2 integer3
\begin_inset Newline newline
\end_inset

Displays the picture whose number is integer1.
 It will be displayed with its top-left corner at a point specified by y
 = integer2 and x = integer3 (in pixels).
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<DISPLAY ,P-TITLE 1 1>
\end_layout

\end_inset


\end_layout

\begin_layout Description
PICINF integer1 table1
\begin_inset Newline newline
\end_inset

Stores the dimensions of the picture whose number is integer1 in table1.
 The height of the picture (in pixels) will be in element 0 and the width
 will be element 1.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<PICINF ,WATERFALL-PIC ,PICINF-TBL>
\end_layout

\end_inset


\end_layout

\begin_layout Description
SOUND integer1 integer2 integer3 integer4
\begin_inset Newline newline
\end_inset

Produce the sound whose number is integer1.
 Integer2, if supplied, has the following meanings: 1 - initialize the sound;
 2 - start the sound (this is the default value); 3 - stop the sound; 4
 - clean up sound buffers.
 If integer3 is supplied, it determines the volume at which the sound will
 be played.
 If integer4 is supplied, it repeats the sound that many times.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SOUND ,CAR-BACKFIRE 2 5 2>
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
Control Operations
\end_layout

\begin_layout Description
CALL routine1 arg1 arg2 arg3
\begin_inset Newline newline
\end_inset

When the compiler encounters a bracketed call to a routine in your ZIL code,
 it converts it into the CALL op-code.
 You don't need to use CALL in your ZIL code.
\end_layout

\begin_layout Description
RETURN anything
\begin_inset Newline newline
\end_inset

Returns any to the routine which called the current routine.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<RETURN .COUNT>
\end_layout

\end_inset


\end_layout

\begin_layout Description
RTRUE 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Returns 1 (that is, true) to the routine which called the current routine.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<RTRUE>
\end_layout

\end_inset


\end_layout

\begin_layout Description
RFALSE 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Returns 0 (that is, false) to the routine which called the current routine.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<RFALSE>
\end_layout

\end_inset


\end_layout

\begin_layout Addsec
Game Commands
\end_layout

\begin_layout Description
QUIT 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

The game should end, in whatever way is appropriate for the machine and
 its operating system.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<QUIT>
\end_layout

\end_inset


\end_layout

\begin_layout Description
RESTART 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Causes the game to act as though it had just started from scratch.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<RESTART>
\end_layout

\end_inset


\end_layout

\begin_layout Description
VERIFY 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

Does a checksum of the bytes in the program to make sure that the program
 is correct.
 Returns true if correct.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<VERIFY>
\end_layout

\end_inset


\end_layout

\begin_layout Description
SAVE table1 integer1 table2
\begin_inset Newline newline
\end_inset

Saves the "impure" part of the game in some permanent, recoverable way,
 as determined by the characteristics of the particular micro.
 I haven't the foggiest idea what the optional arguments are; never seen
 'em used.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<SAVE>
\end_layout

\end_inset


\end_layout

\begin_layout Description
RESTORE table1 integer1 table2
\begin_inset Newline newline
\end_inset

Recovers a previously made save, once again according to a procedure determined
 by the particular interpreter.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<RESTORE>
\end_layout

\end_inset


\end_layout

\begin_layout Description
ISAVE 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

This makes a save, invisible to the player, to the machine's memory (provided
 that the machine has enough memory).
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<ISAVE>
\end_layout

\end_inset


\end_layout

\begin_layout Description
IRESTORE 
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset

This restores the internally-stored RAM-save.
 Together with ISAVE, this is what allows UNDO to work.
 Example:
\begin_inset listings
lstparams "basicstyle={\ttfamily},xleftmargin=25pt"
inline false
status open

\begin_layout Plain Layout

<IRESTORE>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Other instructions (see YZIP Spec for more details):
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="23" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
BTST
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
PRINTC
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
BAND
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
PRINTB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
BOR
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
PRINTI
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
BCOM
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
PRINTR
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
SHIFT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
PRINTT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ASHIFT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
PRINTF
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
NEXTP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
FONT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
GETB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ERASE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
PUTB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
WINGET
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
GETPT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
WINPUT
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
PTSIZE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
DCLEAR
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
VALUE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CALL1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
SET
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CALL2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ASSIGNED?
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
XCALL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
INC
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ICALL1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
DEC
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ICALL2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
IGRTR?
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ICALL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
DLESS?
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
IXCALL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
PUSH
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
CATCH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
XPUSH
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
THROW
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
POP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
JUMP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
FSTACK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
RSTACK
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ZWSTR
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
ORIGINAL?
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_body
\end_document
